{"code": "import sys\nfrom bisect import bisect_left, bisect_right\n\nclass Fenwick:\n    def __init__(self, n):\n        self.n = n\n        self.bit = [0]*(n+2)\n    def add(self, i, v):\n        i += 1\n        while i <= self.n+1:\n            self.bit[i] += v\n            i += i & -i\n    def query(self, i):\n        i += 1\n        s = 0\n        while i:\n            s += self.bit[i]\n            i -= i & -i\n        return s\n    def range_sum(self, l, r):\n        if r < l:\n            return 0\n        return self.query(r)-self.query(l-1)\n\nclass Solution:\n    def countStableSubarrays(self, nums, queries):\n        n = len(nums)\n        left = [0]*n\n        for i in range(1, n):\n            if nums[i-1] > nums[i]:\n                left[i] = i\n            else:\n                left[i] = left[i-1]\n        g = [0]*n\n        for i in range(n):\n            g[i] = i - left[i] + 1\n        pref_g = [0]*(n+1)\n        for i in range(n):\n            pref_g[i+1] = pref_g[i]+g[i]\n        left_pairs = sorted([(left[i], i) for i in range(n)])\n        bit_cnt = Fenwick(n)\n        bit_sum_left = Fenwick(n)\n        ptr = 0\n        qlist = [(l, r, idx) for idx,(l,r) in enumerate(queries)]\n        qlist.sort()\n        ans = [0]*len(queries)\n        for l, r, idx in qlist:\n            while ptr < n and left_pairs[ptr][0] <= l-1:\n                _, i = left_pairs[ptr]\n                bit_cnt.add(i, 1)\n                bit_sum_left.add(i, left[i])\n                ptr += 1\n            cnt = bit_cnt.range_sum(l, r)\n            sum_left_active = bit_sum_left.range_sum(l, r)\n            ans[idx] = pref_g[r+1]-pref_g[l] + sum_left_active - l*cnt\n        return ans\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.countStableSubarrays([3,1,2], [[0,1],[1,2],[0,2]]))\n    print(sol.countStableSubarrays([2,2], [[0,1],[0,0]]))\n    print(sol.countStableSubarrays([8,12], [[1,1]]))", "tests_passed": 3, "score": 0.828125}
{"code": "import sys\nfrom bisect import bisect_left, bisect_right\n\nclass Fenwick:\n    def __init__(self, n):\n        self.n = n\n        self.bit = [0]*(n+1)\n    def add(self, i, v):\n        i+=1\n        n=self.n\n        bit=self.bit\n        while i<=n:\n            bit[i]+=v\n            i+=i&-i\n    def sum(self, i):\n        i+=1\n        s=0\n        bit=self.bit\n        while i>0:\n            s+=bit[i]\n            i-=i&-i\n        return s\n    def range(self, l, r):\n        return self.sum(r)-self.sum(l-1)\n\nclass Solution:\n    def numberOfStableSubarrays(self, nums, queries):\n        n=len(nums)\n        L=[0]*n\n        for i in range(1,n):\n            if nums[i-1]<=nums[i]:\n                L[i]=L[i-1]\n            else:\n                L[i]=i\n        dp=[0]*n\n        pref=[0]*n\n        for i in range(n):\n            dp[i]=i-L[i]+1\n            pref[i]=dp[i]+(pref[i-1] if i>0 else 0)\n        start_to_indices=[[] for _ in range(n)]\n        for i,s in enumerate(L):\n            start_to_indices[s].append(i)\n        queries_with_idx=[(l,r,idx) for idx,(l,r) in enumerate(queries)]\n        queries_with_idx.sort()\n        ft_count=Fenwick(n)\n        ft_sum=Fenwick(n)\n        res=[0]*len(queries)\n        cur_l=0\n        for l,r,idx in queries_with_idx:\n            while cur_l<l:\n                for i in start_to_indices[cur_l]:\n                    ft_count.add(i,1)\n                    ft_sum.add(i,cur_l)\n                cur_l+=1\n            total_dp=pref[r]-(pref[l-1] if l>0 else 0)\n            cnt=ft_count.range(l,r)\n            sumL=ft_sum.range(l,r)\n            res[idx]=total_dp-(cnt*l - sumL)\n        return res", "tests_passed": 3, "score": 0.828125}
{"code": "import sys\n\nclass Fenwick:\n    __slots__ = ('n', 'tree')\n    def __init__(self, n: int):\n        self.n = n\n        self.tree = [0] * (n + 1)\n    def add(self, idx: int, val: int) -> None:\n        i = idx + 1\n        n = self.n + 1\n        while i < n:\n            self.tree[i] += val\n            i += i & -i\n    def sum(self, idx: int) -> int:\n        i = idx + 1\n        res = 0\n        while i:\n            res += self.tree[i]\n            i -= i & -i\n        return res\n    def range_sum(self, l: int, r: int) -> int:\n        if r < l:\n            return 0\n        return self.sum(r) - (self.sum(l - 1) if l > 0 else 0)\n\nclass Solution:\n    def countStableSubarrays(self, nums: list[int], queries: list[list[int]]) -> list[int]:\n        n = len(nums)\n        next_smaller = [n] * n\n        stack = []\n        for i in range(n):\n            while stack and nums[i] < nums[stack[-1]]:\n                next_smaller[stack.pop()] = i\n            stack.append(i)\n        lists_by_next = [[] for _ in range(n + 1)]\n        for i, nxt in enumerate(next_smaller):\n            lists_by_next[nxt].append(i)\n        val_inactive = [0] * n\n        for i in range(n):\n            val_inactive[i] = next_smaller[i] - i\n        active_count = Fenwick(n)\n        active_sum = Fenwick(n)\n        inactive_val = Fenwick(n)\n        for i in range(n):\n            active_count.add(i, 1)\n            active_sum.add(i, i)\n        q = len(queries)\n        ans = [0] * q\n        queries_by_r = [[] for _ in range(n)]\n        for idx, (l, r) in enumerate(queries):\n            queries_by_r[r].append((l, idx))\n        for r in range(n):\n            for i in lists_by_next[r]:\n                active_count.add(i, -1)\n                active_sum.add(i, -i)\n                inactive_val.add(i, val_inactive[i])\n            for l, idx in queries_by_r[r]:\n                ac = active_count.range_sum(l, r)\n                asum = active_sum.range_sum(l, r)\n                res_active = (r + 1) * ac - asum\n                res_inactive = inactive_val.range_sum(l, r)\n                ans[idx] = res_active + res_inactive\n        return ans", "tests_passed": 3, "score": 0.82421875}
{"code": "import sys\nfrom bisect import bisect_left\n\nclass Fenwick:\n    def __init__(self, n):\n        self.n = n\n        self.bit = [0]*(n+1)\n    def add(self, i, v):\n        i+=1\n        n=self.n\n        bit=self.bit\n        while i<=n:\n            bit[i]+=v\n            i+=i&-i\n    def sum(self, i):\n        res=0\n        bit=self.bit\n        i+=1\n        while i>0:\n            res+=bit[i]\n            i-=i&-i\n        return res\n    def range_sum(self,l,r):\n        return self.sum(r)-self.sum(l-1)\n\nclass Solution:\n    def numberOfStableSubarrays(self, nums, queries):\n        n=len(nums)\n        left=[0]*n\n        l_len=[0]*n\n        for i in range(n):\n            if i>0 and nums[i-1]<=nums[i]:\n                l_len[i]=l_len[i-1]+1\n            else:\n                l_len[i]=1\n            left[i]=i-l_len[i]+1\n        diff=[l_len[i] for i in range(n)]\n        pref=[0]*n\n        s=0\n        for i in range(n):\n            s+=diff[i]\n            pref[i]=s\n        pairs=sorted([(left[i],i) for i in range(n)])\n        queries_with_idx=[(l,r,idx) for idx,(l,r) in enumerate(queries)]\n        queries_sorted=sorted(queries_with_idx,key=lambda x:x[0])\n        fenw_cnt=Fenwick(n)\n        fenw_sum=Fenwick(n)\n        res=[0]*len(queries)\n        p=0\n        for L,R,idx in queries_sorted:\n            while p<n and pairs[p][0]<L:\n                val,pidx=pairs[p]\n                fenw_cnt.add(pidx,1)\n                fenw_sum.add(pidx,val)\n                p+=1\n            total_diff=pref[R]-(pref[L-1] if L>0 else 0)\n            cnt=fenw_cnt.range_sum(L,R)\n            sum_left=fenw_sum.range_sum(L,R)\n            res[idx]=total_diff-(L*cnt-sum_left)\n        return res\nif __name__=='__main__':\n    sol=Solution()\n    print(sol.numberOfStableSubarrays([3,1,2],[[0,1],[1,2],[0,2]]))\n    print(sol.numberOfStableSubarrays([2,2],[[0,1],[0,0]]))\n    print(sol.numberOfStableSubarrays([8,12],[[1,1]]))\n", "tests_passed": 3, "score": 0.8203125}
{"code": "import sys\n\nclass Solution:\n    def stableSubarrays(self, nums, queries):\n        n = len(nums)\n        goodEnd = [0] * n\n        goodEnd[-1] = n - 1\n        for i in range(n - 2, -1, -1):\n            if nums[i] <= nums[i + 1]:\n                goodEnd[i] = goodEnd[i + 1]\n            else:\n                goodEnd[i] = i\n        pairs = [(goodEnd[i], i) for i in range(n)]\n        pairs.sort()\n        q = len(queries)\n        qs = []\n        for idx, (l, r) in enumerate(queries):\n            qs.append((r, l, idx))\n        qs.sort()\n        size = n\n        BIT_count = [0] * (size + 2)\n        BIT_sum = [0] * (size + 2)\n        def bit_update(bit, idx, val):\n            i = idx + 1\n            while i <= size:\n                bit[i] += val\n                i += i & -i\n        def bit_query(bit, idx):\n            i = idx + 1\n            s = 0\n            while i > 0:\n                s += bit[i]\n                i -= i & -i\n            return s\n        ans = [0] * q\n        ptr = 0\n        for r, l, qi in qs:\n            while ptr < n and pairs[ptr][0] < r:\n                val, i = pairs[ptr]\n                bit_update(BIT_count, i, 1)\n                bit_update(BIT_sum, i, val)\n                ptr += 1\n            len_seg = r - l + 1\n            first = len_seg * (len_seg + 1) // 2\n            cnt_active = bit_query(BIT_count, r) - (bit_query(BIT_count, l - 1) if l > 0 else 0)\n            sum_active = bit_query(BIT_sum, r) - (bit_query(BIT_sum, l - 1) if l > 0 else 0)\n            second = r * cnt_active - sum_active\n            ans[qi] = first - second\n        return ans\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.stableSubarrays([3,1,2], [[0,1],[1,2],[0,2]]))\n    print(sol.stableSubarrays([2,2], [[0,1],[0,0]]))\n    print(sol.stableSubarrays([8,12], [[1,1]]))\n", "tests_passed": 3, "score": 0.8203125}
{"code": "import bisect\n\nclass Solution:\n    def numberOfStableSubarrays(self, nums, queries):\n        n = len(nums)\n        leftBound = [0]*n\n        left = 0\n        leftBound[0] = 0\n        for i in range(1, n):\n            if nums[i-1] > nums[i]:\n                left = i\n            leftBound[i] = left\n        base = [0]*n\n        for i in range(n):\n            base[i] = i - leftBound[i] + 1\n        prefBase = [0]*(n+1)\n        prefLeft = [0]*(n+1)\n        for i in range(n):\n            prefBase[i+1] = prefBase[i] + base[i]\n            prefLeft[i+1] = prefLeft[i] + leftBound[i]\n        ans = []\n        for l, r in queries:\n            # binary search for first index >= l with leftBound[i] >= l\n            p = bisect.bisect_left(leftBound, l, l, r+1)\n            # sum of base in [l, r]\n            baseSum = prefBase[r+1] - prefBase[l]\n            if p > l:\n                countLeft = p - l\n                sumLeft = prefLeft[p] - prefLeft[l]\n                ans.append(baseSum - (countLeft * l - sumLeft))\n            else:\n                ans.append(baseSum)\n        return ans", "tests_passed": 3, "score": 0.81640625}
{"code": "import sys\nfrom bisect import bisect_right\n\nclass BIT:\n    __slots__ = ('n','tree')\n    def __init__(self,n:int):\n        self.n=n\n        self.tree=[0]*(n+2)\n    def add(self,i:int,v:int):\n        i+=1\n        n=self.n+2\n        t=self.tree\n        while i<n:\n            t[i]+=v\n            i+=i&-i\n    def sum(self,i:int):\n        i+=1\n        s=0\n        t=self.tree\n        while i>0:\n            s+=t[i]\n            i-=i&-i\n        return s\n    def range_sum(self,l:int,r:int):\n        return self.sum(r)-self.sum(l-1)\n\nclass Solution:\n    def stableSubarrays(self, nums, queries):\n        n=len(nums)\n        end=[0]*n\n        end[-1]=n-1\n        for i in range(n-2,-1,-1):\n            if nums[i]<=nums[i+1]:\n                end[i]=end[i+1]\n            else:\n                end[i]=i\n        prefIdx=[0]*(n+1)\n        for i in range(n):\n            prefIdx[i+1]=prefIdx[i]+i\n        # sort indices by end value\n        idx_by_end=sorted(range(n), key=lambda x:end[x])\n        # queries with original indices\n        q_with_idx=[(l,r,idx) for idx,(l,r) in enumerate(queries)]\n        q_sorted=sorted(q_with_idx, key=lambda x:x[1])\n        bit_sum=BIT(n)\n        bit_cnt=BIT(n)\n        ptr=0\n        ans=[0]*len(queries)\n        for l,r,qi in q_sorted:\n            while ptr<n and end[idx_by_end[ptr]]<=r:\n                i=idx_by_end[ptr]\n                bit_sum.add(i,end[i])\n                bit_cnt.add(i,1)\n                ptr+=1\n            sumEnd=bit_sum.range_sum(l,r)\n            cntEnd=bit_cnt.range_sum(l,r)\n            totalCount=r-l+1\n            countGreater=totalCount-cntEnd\n            sumIdx=prefIdx[r+1]-prefIdx[l]\n            ans[qi]=sumEnd + r*countGreater - sumIdx + totalCount\n        return ans", "tests_passed": 3, "score": 0.81640625}
{"code": "import sys\n\nclass Solution:\n    def stableSubarrays(self, nums, queries):\n        n = len(nums)\n        next_smaller = [n] * n\n        stack = []\n        for i, val in enumerate(nums):\n            while stack and val < nums[stack[-1]]:\n                idx = stack.pop()\n                next_smaller[idx] = i\n            stack.append(i)\n        f = [next_smaller[i] - 1 for i in range(n)]\n        d = f  # alias\n\n        q = len(queries)\n        order = sorted(range(q), key=lambda idx: queries[idx][1])\n        bit_count = [0] * (n + 1)\n        bit_sum = [0] * (n + 1)\n\n        def bit_add(bit, pos, val):\n            pos += 1\n            while pos <= n:\n                bit[pos] += val\n                pos += pos & -pos\n\n        def bit_sum_range(bit, l, r):\n            def prefix(p):\n                s = 0\n                while p > 0:\n                    s += bit[p]\n                    p -= p & -p\n                return s\n            return prefix(r + 1) - prefix(l)\n\n        ptr = 0\n        d_sorted = sorted(range(n), key=lambda i: d[i])\n        ans = [0] * q\n        for qi in order:\n            l, r = queries[qi]\n            while ptr < n and d[d_sorted[ptr]] < r:\n                idx = d_sorted[ptr]\n                bit_add(bit_count, idx, 1)\n                bit_add(bit_sum, idx, d[idx])\n                ptr += 1\n            cnt = bit_sum_range(bit_count, l, r)\n            sum_d = bit_sum_range(bit_sum, l, r)\n            base = (r - l + 1) * (r - l + 2) // 2\n            ans[qi] = base - r * cnt + sum_d\n        return ans\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.stableSubarrays([3,1,2], [[0,1],[1,2],[0,2]]))\n    print(sol.stableSubarrays([2,2], [[0,1],[0,0]]))\n    print(sol.stableSubarrays([8,12], [[1,1]]))", "tests_passed": 3, "score": 0.81640625}
{"code": "import sys\n\nclass Solution:\n    def numberOfStableSubarrays(self, nums, queries):\n        n = len(nums)\n        dp = [0]*n\n        start = [0]*n\n        dp[0] = 1\n        start[0] = 0\n        for i in range(1,n):\n            if nums[i-1] <= nums[i]:\n                dp[i] = dp[i-1]+1\n            else:\n                dp[i] = 1\n            start[i] = i - dp[i] + 1\n        pref = [0]*(n+1)\n        for i in range(n):\n            pref[i+1] = pref[i] + dp[i]\n        LOG = (n+1).bit_length()\n        st = [[0]*n for _ in range(LOG)]\n        for i in range(n):\n            st[0][i] = start[i]\n        for k in range(1,LOG):\n            step = 1<<(k-1)\n            for i in range(n-(1<<k)+1):\n                st[k][i] = max(st[k-1][i], st[k-1][i+step])\n        def range_max(l,r):\n            length = r-l+1\n            k = length.bit_length()-1\n            return max(st[k][l], st[k][r-(1<<k)+1])\n        ans = []\n        for l,r in queries:\n            low, high = l, r\n            while low < high:\n                mid = (low+high)//2\n                if range_max(l,mid) >= l:\n                    high = mid\n                else:\n                    low = mid+1\n            if start[low] >= l:\n                m = low\n            else:\n                m = r+1\n            if m>r:\n                length = r-l+1\n                ans.append(length*(length+1)//2)\n            else:\n                left_len = m-l\n                left_sum = left_len*(left_len+1)//2\n                right_sum = pref[r+1]-pref[m]\n                ans.append(left_sum+right_sum)\n        return ans", "tests_passed": 3, "score": 0.81640625}
{"code": "import sys\n\nclass Fenwick:\n    def __init__(self, n):\n        self.n = n\n        self.bit = [0] * (n + 2)\n    def add(self, i, v):\n        i += 1\n        while i <= self.n + 1:\n            self.bit[i] += v\n            i += i & -i\n    def pref(self, i):\n        i += 1\n        s = 0\n        while i > 0:\n            s += self.bit[i]\n            i -= i & -i\n        return s\n    def range(self, l, r):\n        if r < l:\n            return 0\n        return self.pref(r) - self.pref(l - 1)\n\nclass Solution:\n    def countStableSubarrays(self, nums, queries):\n        n = len(nums)\n        right = [0] * n\n        right[n - 1] = n - 1\n        for i in range(n - 2, -1, -1):\n            if nums[i] <= nums[i + 1]:\n                right[i] = right[i + 1]\n            else:\n                right[i] = i\n        q = len(queries)\n        queries_with_idx = [(l, r, idx) for idx, (l, r) in enumerate(queries)]\n        queries_with_idx.sort(key=lambda x: x[1])\n        ft_count = Fenwick(n)\n        ft_sum = Fenwick(n)\n        ans = [0] * q\n        add_ptr = 0\n        for l, R, idx in queries_with_idx:\n            while add_ptr < n and right[add_ptr] <= R:\n                ft_count.add(add_ptr, 1)\n                ft_sum.add(add_ptr, right[add_ptr])\n                add_ptr += 1\n            count_le = ft_count.range(l, R)\n            sum_right_le = ft_sum.range(l, R)\n            count = R - l + 1\n            sum_i = (l + R) * count // 2\n            sum_f = sum_right_le + R * (count - count_le)\n            ans[idx] = sum_f - sum_i + count\n        return ans\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.countStableSubarrays([3,1,2], [[0,1],[1,2],[0,2]]))\n    print(sol.countStableSubarrays([2,2], [[0,1],[0,0]]))\n    print(sol.countStableSubarrays([8,12], [[1,1]]))\n", "tests_passed": 3, "score": 0.81640625}
{"code": "import sys\n\nclass Solution:\n    def countStableSubarrays(self, nums, queries):\n        n = len(nums)\n        start = [0]*n\n        for i in range(1, n):\n            if nums[i-1] <= nums[i]:\n                start[i] = start[i-1]\n            else:\n                start[i] = i\n        cnt = [0]*n\n        for i in range(n):\n            cnt[i] = i - start[i] + 1\n        prefCnt = [0]*(n+1)\n        for i in range(n):\n            prefCnt[i+1] = prefCnt[i] + cnt[i]\n        groups = [[] for _ in range(n)]\n        for j in range(n):\n            groups[start[j]].append(j)\n        class BIT:\n            def __init__(self, size):\n                self.n = size\n                self.bit = [0]*(size+2)\n            def add(self, idx, val):\n                i = idx+1\n                while i <= self.n+1:\n                    self.bit[i] += val\n                    i += i & -i\n            def sum(self, idx):\n                if idx < 0:\n                    return 0\n                i = idx+1\n                s = 0\n                while i>0:\n                    s += self.bit[i]\n                    i -= i & -i\n                return s\n        bitCnt = BIT(n)\n        bitSum = BIT(n)\n        res = [0]*len(queries)\n        queriesWithIdx = [(l, r, idx) for idx,(l,r) in enumerate(queries)]\n        queriesWithIdx.sort()\n        curL = 0\n        for l, r, qi in queriesWithIdx:\n            while curL <= l-1:\n                for j in groups[curL]:\n                    bitCnt.add(j, 1)\n                    bitSum.add(j, start[j])\n                curL += 1\n            totalCnt = prefCnt[r+1] - prefCnt[l]\n            lessCnt = bitCnt.sum(r) - bitCnt.sum(l-1)\n            lessSum = bitSum.sum(r) - bitSum.sum(l-1)\n            res[qi] = totalCnt - lessCnt*l + lessSum\n        return res\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.countStableSubarrays([3,1,2], [[0,1],[1,2],[0,2]]))\n    print(sol.countStableSubarrays([2,2], [[0,1],[0,0]]))\n    print(sol.countStableSubarrays([8,12], [[1,1]]))\n", "tests_passed": 3, "score": 0.8125}
{"code": "import bisect\n\nclass Solution:\n    def countStableSubarrays(self, nums, queries):\n        n = len(nums)\n        run_start = []\n        run_index = [0] * n\n        idx = 0\n        run_start.append(0)\n        for i in range(1, n):\n            if nums[i-1] > nums[i]:\n                run_start.append(i)\n                idx += 1\n            run_index[i] = idx\n        run_start.append(n)  # sentinel\n        run_count = len(run_start) - 1\n        run_end = [0] * run_count\n        for i in range(run_count):\n            run_end[i] = run_start[i+1] - 1\n        run_len = [run_end[i] - run_start[i] + 1 for i in range(run_count)]\n        sub_count = [l * (l + 1) // 2 for l in run_len]\n        prefix = [0] * run_count\n        s = 0\n        for i in range(run_count):\n            s += sub_count[i]\n            prefix[i] = s\n        ans = []\n        for l, r in queries:\n            rl = run_index[l]\n            rr = run_index[r]\n            if rl == rr:\n                length = r - l + 1\n                ans.append(length * (length + 1) // 2)\n                continue\n            left_len = run_end[rl] - l + 1\n            left_cnt = left_len * (left_len + 1) // 2\n            right_len = r - run_start[rr] + 1\n            right_cnt = right_len * (right_len + 1) // 2\n            middle = 0\n            if rl + 1 <= rr - 1:\n                middle = prefix[rr - 1] - prefix[rl]\n            ans.append(left_cnt + middle + right_cnt)\n        return ans\n", "tests_passed": 3, "score": 0.8125}
{"code": "import sys\n\nclass Fenwick:\n    def __init__(self, n):\n        self.n = n\n        self.bit = [0]*(n+2)\n    def add(self, idx, val):\n        i = idx+1\n        while i <= self.n+1:\n            self.bit[i] += val\n            i += i&-i\n    def sum(self, idx):\n        i = idx+1\n        s = 0\n        while i>0:\n            s += self.bit[i]\n            i -= i&-i\n        return s\n    def range_sum(self, l, r):\n        return self.sum(r)-self.sum(l-1)\n\nclass Solution:\n    def stableSubarrays(self, nums, queries):\n        n = len(nums)\n        left = [0]*n\n        for i in range(1, n):\n            if nums[i-1] <= nums[i]:\n                left[i] = left[i-1]\n            else:\n                left[i] = i\n        f = [i-left[i]+1 for i in range(n)]\n        pre_i1 = [0]*n\n        pre_left = [0]*n\n        for i in range(n):\n            pre_i1[i] = pre_i1[i-1] + (i+1) if i>0 else (i+1)\n            pre_left[i] = pre_left[i-1] + left[i] if i>0 else left[i]\n        buckets = [[] for _ in range(n)]\n        for i in range(n):\n            buckets[left[i]].append(i)\n        queries_with_idx = [(l, r, idx) for idx,(l,r) in enumerate(queries)]\n        queries_with_idx.sort(key=lambda x: x[0])\n        bit_cnt = Fenwick(n)\n        bit_sum = Fenwick(n)\n        ans = [0]*len(queries)\n        curr_l = 0\n        for l,r,idx in queries_with_idx:\n            while curr_l <= l:\n                for pos in buckets[curr_l]:\n                    bit_cnt.add(pos,1)\n                    bit_sum.add(pos,left[pos])\n                curr_l +=1\n            total = (pre_i1[r] - (pre_i1[l-1] if l>0 else 0))\n            total_left_sum = pre_left[r] - (pre_left[l-1] if l>0 else 0)\n            sum_left_leq = bit_sum.range_sum(l,r)\n            cnt_leq = bit_cnt.range_sum(l,r)\n            ans[idx] = total - total_left_sum + sum_left_leq - l*cnt_leq\n        return ans\n", "tests_passed": 3, "score": 0.8125}
{"code": "import sys\nclass Solution:\n    def countStableSubarrays(self, nums, queries):\n        n = len(nums)\n        inc = [0]*n\n        inc[0] = 1\n        for i in range(1, n):\n            inc[i] = inc[i-1]+1 if nums[i-1] <= nums[i] else 1\n        pref = [0]*(n+1)\n        for i in range(n):\n            pref[i+1] = pref[i]+inc[i]\n        A = [i-inc[i]+1 for i in range(n)]\n        qcnt = len(queries)\n        ans = [0]*qcnt\n        sorted_q = sorted([(l,r,idx) for idx,(l,r) in enumerate(queries)])\n        idxA = sorted(range(n), key=lambda i: A[i])\n        ptr = 0\n        size = n\n        class BIT:\n            __slots__=('n','bit')\n            def __init__(self,n):\n                self.n=n\n                self.bit=[0]*(n+1)\n            def add(self,i,v):\n                i+=1\n                while i<=self.n:\n                    self.bit[i]+=v\n                    i+=i&-i\n            def sum(self,i):\n                s=0\n                i+=1\n                while i>0:\n                    s+=self.bit[i]\n                    i-=i&-i\n                return s\n            def range_sum(self,l,r):\n                return self.sum(r)-self.sum(l-1)\n        bitCnt = BIT(n)\n        bitSum = BIT(n)\n        for l,r,qi in sorted_q:\n            while ptr<n and A[idxA[ptr]]<l:\n                i=idxA[ptr]\n                bitCnt.add(i,1)\n                bitSum.add(i,A[i])\n                ptr+=1\n            base = pref[r+1]-pref[l]\n            cnt = bitCnt.range_sum(l,r)\n            sumA = bitSum.range_sum(l,r)\n            ans[qi]=base+sumA - l*cnt\n        return ans\nif __name__=='__main__':\n    sol=Solution()\n    print(sol.countStableSubarrays([3,1,2],[[0,1],[1,2],[0,2]]))\n    print(sol.countStableSubarrays([2,2],[[0,1],[0,0]]))\n    print(sol.countStableSubarrays([8,12],[[1,1]]))", "tests_passed": 3, "score": 0.8125}
{"code": "import bisect\n\nclass Solution:\n    def countStableSubarrays(self, nums, queries):\n        n = len(nums)\n        start = [0]*n\n        for i in range(1, n):\n            if nums[i-1] > nums[i]:\n                start[i] = i\n            else:\n                start[i] = start[i-1]\n        len_arr = [i - start[i] + 1 for i in range(n)]\n        pref = [0]*n\n        s = 0\n        for i, v in enumerate(len_arr):\n            s += v\n            pref[i] = s\n        res = []\n        for l, r in queries:\n            j = bisect.bisect_right(start, l, l)\n            if j > r:\n                j = r + 1\n            part1 = (j - l) * (j - l + 1) // 2\n            part2 = pref[r] - (pref[j-1] if j-1 >= 0 else 0)\n            res.append(part1 + part2)\n        return res", "tests_passed": 3, "score": 0.80859375}
{"code": "import bisect\nclass Solution:\n    def numberOfStableSubarrays(self, nums, queries):\n        n=len(nums)\n        s=[0]*n\n        for i in range(1,n):\n            s[i]=s[i-1] if nums[i]>=nums[i-1] else i\n        pref_i=[0]*n\n        pref_s=[0]*n\n        pref_i[0]=0\n        pref_s[0]=s[0]\n        for i in range(1,n):\n            pref_i[i]=pref_i[i-1]+i\n            pref_s[i]=pref_s[i-1]+s[i]\n        res=[]\n        for l,r in queries:\n            pos=bisect.bisect_left(s,l,lo=l)\n            if pos>r:\n                pos=r+1\n            part1=0\n            if pos>l:\n                t=pos-l\n                sum_i=pref_i[pos-1]-(pref_i[l-1] if l>0 else 0)\n                part1=sum_i - t*l + t\n            part2=0\n            if pos<=r:\n                count=r-pos+1\n                sum_i=pref_i[r]-(pref_i[pos-1] if pos>0 else 0)\n                sum_s=pref_s[r]-(pref_s[pos-1] if pos>0 else 0)\n                part2=(sum_i+count)-sum_s\n            res.append(part1+part2)\n        return res", "tests_passed": 3, "score": 0.80859375}
{"code": "import bisect\nfrom typing import List\n\nclass Solution:\n    def countStableSubarrays(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(nums)\n        f = [0]*n\n        next_break = n\n        for i in range(n-1, -1, -1):\n            if i==n-1 or nums[i] > nums[i+1]:\n                next_break = i+1\n            f[i] = next_break-1\n        g = [f[i]-i+1 for i in range(n)]\n        pref_g = [0]*(n+1)\n        pref_i = [0]*(n+1)\n        for i in range(n):\n            pref_g[i+1] = pref_g[i] + g[i]\n            pref_i[i+1] = pref_i[i] + i\n        res = []\n        for l, r in queries:\n            idx = bisect.bisect_right(f, r)\n            m = idx-1\n            part1 = 0\n            if m >= l:\n                part1 = pref_g[m+1] - pref_g[l]\n            start = l if m < l else m+1\n            part2 = 0\n            if start <= r:\n                cnt = r - start + 1\n                sum_i = pref_i[r+1] - pref_i[start]\n                part2 = (r+1)*cnt - sum_i\n            res.append(part1 + part2)\n        return res\n", "tests_passed": 3, "score": 0.80859375}
{"code": "import sys\n\nclass Solution:\n    def countStableSubarrays(self, nums, queries):\n        n = len(nums)\n        # compute R[s]\n        R = [0]*n\n        lastBad = n\n        for i in range(n-1, -1, -1):\n            if i < n-1 and nums[i] > nums[i+1]:\n                lastBad = i+1\n            R[i] = lastBad - 1\n        len_arr = [R[i]-i+1 for i in range(n)]\n        # group indices by R value\n        byR = [[] for _ in range(n+1)]\n        for i in range(n):\n            byR[R[i]].append(i)\n        # Fenwick tree\n        class Fenwick:\n            __slots__ = ('n','bit')\n            def __init__(self,n):\n                self.n=n\n                self.bit=[0]*(n+1)\n            def add(self,i,v):\n                i+=1\n                bit=self.bit\n                n=self.n\n                while i<=n:\n                    bit[i]+=v\n                    i+=i&-i\n            def sum(self,i):\n                res=0\n                bit=self.bit\n                while i>0:\n                    res+=bit[i]\n                    i-=i&-i\n                return res\n            def range(self,l,r):\n                return self.sum(r+1)-self.sum(l)\n        ft_len = Fenwick(n)\n        ft_cnt = Fenwick(n)\n        ft_idx = Fenwick(n)\n        for i in range(n):\n            ft_cnt.add(i,1)\n            ft_idx.add(i,i)\n        # process queries sorted by r\n        qs = [(r,l,idx) for idx,(l,r) in enumerate(queries)]\n        qs.sort()\n        ans=[0]*len(queries)\n        cur=0\n        for r,l,qi in qs:\n            while cur<=r:\n                for s in byR[cur]:\n                    ft_len.add(s,len_arr[s])\n                    ft_cnt.add(s,-1)\n                    ft_idx.add(s,-s)\n                cur+=1\n            activeSum=ft_len.range(l,r)\n            inactiveCnt=ft_cnt.range(l,r)\n            inactiveIdx=ft_idx.range(l,r)\n            ans[qi]=activeSum + (r+1)*inactiveCnt - inactiveIdx\n        return ans\nif __name__==\"__main__\":\n    sol=Solution()\n    print(sol.countStableSubarrays([3,1,2],[[0,1],[1,2],[0,2]]))\n    print(sol.countStableSubarrays([2,2],[[0,1],[0,0]]))\n    print(sol.countStableSubarrays([8,12],[[1,1]]))", "tests_passed": 3, "score": 0.80078125}
{"code": "import sys\n\nclass Fenwick:\n    def __init__(self, n):\n        self.n = n\n        self.bit = [0]*(n+2)\n    def add(self, i, v):\n        i += 1\n        while i <= self.n+1:\n            self.bit[i] += v\n            i += i & -i\n    def sum(self, i):\n        i += 1\n        s = 0\n        while i>0:\n            s += self.bit[i]\n            i -= i & -i\n        return s\n    def range_sum(self, l, r):\n        if r<l: return 0\n        return self.sum(r)-self.sum(l-1)\n\nclass Solution:\n    def numberOfStableSubarrays(self, nums, queries):\n        n = len(nums)\n        left_len = [0]*n\n        left_len[0] = 1\n        for i in range(1, n):\n            if nums[i-1] <= nums[i]:\n                left_len[i] = left_len[i-1]+1\n            else:\n                left_len[i] = 1\n        l0 = [0]*n\n        base = [0]*n\n        for i in range(n):\n            l0[i] = i - left_len[i] + 1\n            base[i] = i+1 - left_len[i]\n        events = [[] for _ in range(n+2)]\n        for i in range(n):\n            ev = l0[i]+1\n            if ev<=n:\n                events[ev].append(i)\n        fen_left = Fenwick(n)\n        fen_base = Fenwick(n)\n        fen_count = Fenwick(n)\n        for i in range(n):\n            fen_left.add(i, left_len[i])\n        ans = [0]*len(queries)\n        qs = sorted([(l,r,idx) for idx,(l,r) in enumerate(queries)])\n        ptr = 0\n        for l,r,idx in qs:\n            while ptr <= l:\n                for i in events[ptr]:\n                    fen_left.add(i, -left_len[i])\n                    fen_base.add(i, base[i])\n                    fen_count.add(i, 1)\n                ptr += 1\n            left_sum = fen_left.range_sum(l,r)\n            base_sum = fen_base.range_sum(l,r)\n            cnt = fen_count.range_sum(l,r)\n            ans[idx] = left_sum + base_sum - l*cnt\n        return ans\n", "tests_passed": 2, "score": 0.82421875}
{"code": "import sys\n\nclass BIT:\n    __slots__ = (\"n\", \"bit\")\n    def __init__(self, n: int):\n        self.n = n\n        self.bit = [0] * (n + 1)\n    def add(self, idx: int, val: int):\n        i = idx + 1\n        while i <= self.n:\n            self.bit[i] += val\n            i += i & -i\n    def sum(self, idx: int):\n        res = 0\n        i = idx + 1\n        while i:\n            res += self.bit[i]\n            i -= i & -i\n        return res\n    def range_sum(self, l: int, r: int):\n        if r < l:\n            return 0\n        return self.sum(r) - (self.sum(l - 1) if l > 0 else 0)\n\nclass Solution:\n    def numberOfStableSubarrays(self, nums: list[int], queries: list[list[int]]) -> list[int]:\n        n = len(nums)\n        f = [0] * n\n        for i in range(n - 1, -1, -1):\n            if i == n - 1:\n                f[i] = n\n            elif nums[i] > nums[i + 1]:\n                f[i] = i + 1\n            else:\n                f[i] = f[i + 1]\n        a1 = [f[i] - i for i in range(n)]\n        pref_a1 = [0] * (n + 1)\n        for i in range(n):\n            pref_a1[i + 1] = pref_a1[i] + a1[i]\n        indices = list(range(n))\n        indices.sort(key=lambda x: f[x], reverse=True)\n        q = len(queries)\n        qs = []\n        for idx, (l, r) in enumerate(queries):\n            T = r + 1\nimport sys\n\nclass Solution:\n    def stableSubarrays(self, nums, queries):\n        n = len(nums)\n        len_arr = [0]*n\n        len_arr[0] = 1\n        for i in range(1,n):\n            if nums[i-1] <= nums[i]:\n                len_arr[i] = len_arr[i-1] + 1\n            else:\n                len_arr[i] = 1\n        pref_len = [0]*(n+1)\n        for i in range(n):\n            pref_len[i+1] = pref_len[i] + len_arr[i]\n        A = [0]*n\n        thresh = [0]*n\n        for i in range(n):\n            A[i] = len_arr[i] - i - 1\n            thresh[i] = i - len_arr[i] + 1\n        thresh_next = [t+1 for t in thresh]\n        order = sorted(range(n), key=lambda x: thresh_next[x])\n        idx_ptr = 0\n        size = n+2\n        bit_sum = [0]*size\n        bit_cnt = [0]*size\n        def bit_update(bit, i, val):\n            i += 1\n            while i < size:\n                bit[i] += val\n                i += i & -i\n        def bit_query(bit, i):\n            i += 1\n            s = 0\n            while i>0:\n                s += bit[i]\n                i -= i & -i\n            return s\n        def bit_range(bit, l, r):\n            return bit_query(bit, r) - (bit_query(bit, l-1) if l>0 else 0)\n        sorted_queries = sorted([(l,r,i) for i,(l,r) in enumerate(queries)], key=lambda x: x[0])\n        ans = [0]*len(queries)\n        curr_l = 0\n        for l,r,qi in sorted_queries:\n            while idx_ptr < n and order[idx_ptr] < l:\n                e = order[idx_ptr]\n                bit_update(bit_sum, e, A[e])\n                bit_update(bit_cnt, e, 1)\n                idx_ptr += 1\n            sum_len = pref_len[r+1] - pref_len[l]\n            cnt = bit_range(bit_cnt, l, r)\n            sum_a = bit_range(bit_sum, l, r)\n            ans[qi] = sum_len - (sum_a + l*cnt)\n        return ans", "tests_passed": 2, "score": 0.80078125}
{"code": "import sys\n\nclass Solution:\n    def countStableSubarrays(self, nums, queries):\n        n = len(nums)\n        bad = [0] * (n - 1)\n        for i in range(n - 1):\n            if nums[i] > nums[i + 1]:\n                bad[i] = 1\n        nextBad = [n] * n\n        nxt = n\n        for i in range(n - 1, -1, -1):\n            if i < n - 1 and bad[i]:\n                nxt = i\n            nextBad[i] = nxt\n        pos_by_next = sorted([(nextBad[i], i) for i in range(n)])\n        qlist = [(r + 1, l, r, idx) for idx, (l, r) in enumerate(queries)]\n        qlist.sort()\n        class Fenwick:\n            def __init__(self, size):\n                self.n = size\n                self.bit = [0] * (size + 1)\n            def add(self, idx, val):\n                i = idx + 1\n                while i <= self.n:\n                    self.bit[i] += val\n                    i += i & -i\n            def sum(self, idx):\n                s = 0\n                i = idx + 1\n                while i > 0:\n                    s += self.bit[i]\n                    i -= i & -i\n                return s\n            def range_sum(self, l, r):\n                if r < l:\n                    return 0\n                return self.sum(r) - (self.sum(l - 1) if l > 0 else 0)\n        bitCnt = Fenwick(n)\n        bitSum = Fenwick(n)\n        ptr = 0\n        ans = [0] * len(queries)\n        for T, l, r, idx in qlist:\n            while ptr < n and pos_by_next[ptr][0] <= T:\n                nb, pos = pos_by_next[ptr]\n                bitCnt.add(pos, 1)\n                bitSum.add(pos, nb)\n                ptr += 1\n            cntLess = bitCnt.range_sum(l, r)\n            sumLess = bitSum.range_sum(l, r)\n            total = r - l + 1\n            cntGreater = total - cntLess\n            sumMin = sumLess + T * cntGreater\n            totalIndicesSum = (l + r) * total // 2\n            ans[idx] = sumMin - totalIndicesSum\n        return ans\nif __name__ == \"__main__\":\n    pass", "tests_passed": 2, "score": 0.75390625}
{"code": "import sys\nfrom bisect import bisect_left, bisect_right\nclass BIT:\n    def __init__(self,n):\n        self.n=n\n        self.bit=[0]*(n+2)\n    def add(self,i,v):\n        i+=1\n        while i<=self.n+1:\n            self.bit[i]+=v\n            i+=i&-i\n    def query(self,i):\n        i+=1\n        s=0\n        while i>0:\n            s+=self.bit[i]\n            i-=i&-i\n        return s\nclass Solution:\n    def numberOfStableSubarrays(self, nums, queries):\n        n=len(nums)\n        l=[0]*n\n        for i in range(1,n):\n            if nums[i-1]>nums[i]:\n                l[i]=i\n            else:\n                l[i]=l[i-1]\n        prefSum1=[0]*(n+1)\n        for i in range(n):\n            prefSum1[i+1]=prefSum1[i]+(i+1)\n        prefL=[0]*(n+1)\n        for i in range(n):\n            prefL[i+1]=prefL[i]+l[i]\n        pos_by_l=[[] for _ in range(n)]\n        for i,val in enumerate(l):\n            pos_by_l[val].append(i)\n        queries_with_idx=[(lq,rq,idx) for idx,(lq,rq) in enumerate(queries)]\n        queries_with_idx.sort(reverse=True)\n        bit_sum=BIT(n)\n        bit_count=BIT(n)\n        ans=[0]*len(queries)\n        cur_l=n\n        qi=0\n        while qi<len(queries_with_idx):\n            lq,rq,_=queries_with_idx[qi]\n            while cur_l>lq:\n                cur_l-=1\n                for i in pos_by_l[cur_l]:\n                    bit_sum.add(i,l[i])\n                    bit_count.add(i,1)\n            idx=queries_with_idx[qi][2]\n            lq,rq,_=queries_with_idx[qi]\n            sum_range=prefL[rq+1]-prefL[lq]\n            sum_small=bit_sum.query(rq)-bit_sum.query(lq-1)\n            count_small=bit_count.query(rq)-bit_count.query(lq-1)\n            sum_large=sum_range-sum_small\n            sum_max=lq*count_small+sum_large\n            total=(prefSum1[rq+1]-prefSum1[lq])\n            ans[idx]=total-sum_max\n            qi+=1\n        return ans\nif __name__==\"__main__\":\n    sol=Solution()\n    print(sol.numberOfStableSubarrays([3,1,2],[[0,1],[1,2],[0,2]]))\n    print(sol.numberOfStableSubarrays([2,2],[[0,1],[0,0]]))\n    print(sol.numberOfStableSubarrays([8,12],[[1,1]]) )", "tests_passed": 1, "score": 0.82421875}
{"code": "import sys\nfrom collections import defaultdict\n\nclass BIT:\n    def __init__(self, n):\n        self.n = n\n        self.t = [0]*(n+1)\n    def add(self, i, v):\n        i+=1\n        while i<=self.n:\n            self.t[i]+=v\n            i+=i&-i\n    def sum(self, i):\n        s=0\n        i+=1\n        while i>0:\n            s+=self.t[i]\n            i-=i&-i\n        return s\n    def range(self, l, r):\n        if r<l:\n            return 0\n        return self.sum(r)-self.sum(l-1)\n\nclass Solution:\n    def countStableSubarrays(self, nums, queries):\n        n=len(nums)\n        left=[0]*n\n        for i in range(n):\n            if i==0 or nums[i-1]>nums[i]:\n                left[i]=i\n            else:\n                left[i]=left[i-1]\n        f=[i-left[i]+1 for i in range(n)]\n        pf=[0]*(n+1)\n        for i in range(n):\n            pf[i+1]=pf[i]+f[i]\n        groups=defaultdict(list)\n        for i,l in enumerate(left):\n            groups[l].append(i)\n        queries_by_l=defaultdict(list)\n        for idx,(l,r) in enumerate(queries):\n            queries_by_l[l].append((idx,l,r))\n        bit_sum=BIT(n)\n        bit_cnt=BIT(n)\n        ans=[0]*len(queries)\n        for l in reversed(range(n)):\n            if l+1<n:\n                for j in groups[l+1]:\n                    bit_sum.add(j,left[j])\n                    bit_cnt.add(j,1)\n            for idx,ql,qr in queries_by_l.get(l,[]):\n                sum_f=pf[qr+1]-pf[ql]\n                sum_left=bit_sum.range(ql,qr)\n                cnt=bit_cnt.range(ql,qr)\n                subtract=sum_left-cnt*l\n                ans[idx]=sum_f-subtract\n        return ans\n", "tests_passed": 1, "score": 0.8203125}
{"code": "import sys\nfrom collections import defaultdict\n\nclass Fenwick:\n    def __init__(self, n):\n        self.n = n\n        self.bit = [0]*(n+1)\n    def add(self, idx, val):\n        i = idx+1\n        n = self.n\n        bit = self.bit\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n    def sum(self, idx):\n        if idx < 0:\n            return 0\n        i = idx+1\n        s = 0\n        bit = self.bit\n        while i > 0:\n            s += bit[i]\n            i -= i & -i\n        return s\n\nclass Solution:\n    def countStableSubarrays(self, nums, queries):\n        n = len(nums)\n        left = [0]*n\n        for i in range(n):\n            if i>0 and nums[i-1] <= nums[i]:\n                left[i] = left[i-1]+1\n            else:\n                left[i] = 1\n        s = [i-left[i]+1 for i in range(n)]\n        pref_i1 = [0]*n\n        ssum = 0\n        for i in range(n):\n            ssum += i+1\n            pref_i1[i] = ssum\n        buckets = [[] for _ in range(n)]\n        for i in range(n):\n            buckets[s[i]].append(i)\n        sumBIT = Fenwick(n)\n        countBIT = Fenwick(n)\n        for i in range(n):\n            sumBIT.add(i, s[i])\n        queries_with_idx = [(l,r,idx) for idx,(l,r) in enumerate(queries)]\n        queries_with_idx.sort(key=lambda x: x[0], reverse=True)\n        ans = [0]*len(queries)\n        for l,r,qi in queries_with_idx:\n            for idx in buckets[l]:\n                sumBIT.add(idx, -s[idx])\n                countBIT.add(idx, 1)\n            cnt = countBIT.sum(r)-countBIT.sum(l-1)\n            sum_s_gt = sumBIT.sum(r)-sumBIT.sum(l-1)\n            total_i1 = pref_i1[r] - (pref_i1[l-1] if l>0 else 0)\n            ans[qi] = total_i1 - (cnt*l + sum_s_gt)\n        return ans\nif __name__==\"__main__\":\n    pass", "tests_passed": 1, "score": 0.8203125}
{"code": "import bisect,math,sys\nfrom typing import List\n\nclass BIT:\n    __slots__=('n','t')\n    def __init__(self,n:int):\n        self.n=n\n        self.t=[0]*(n+1)\n    def add(self,i:int,v:int):\n        i+=1\n        t=self.t\n        n=self.n\n        while i<=n:\n            t[i]+=v\n            i+=i&-i\n    def sum(self,i:int):\n        s=0\n        t=self.t\n        i+=1\n        while i>0:\n            s+=t[i]\n            i-=i&-i\n        return s\n    def range_sum(self,l:int,r:int):\n        if r<l:return 0\n        return self.sum(r)-self.sum(l-1)\n\nclass Solution:\n    def numberOfStableSubarrays(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        n=len(nums)\n        f=[0]*n\n        f[0]=0\n        for i in range(1,n):\n            if nums[i-1]<=nums[i]:\n                f[i]=f[i-1]\n            else:\n                f[i]=i\n        # f[i] is leftmost index of non-decreasing run ending at i\n        right=[0]*n\n        for i in range(n-1,-1,-1):\n            if i==n-1 or nums[i]>nums[i+1]:\n                right[i]=i\n            else:\n                right[i]=right[i+1]\n        # Build list by right boundary\n        byRight=[[] for _ in range(n)]\n        for i,r in enumerate(right):\n            byRight[r].append(i)\n        # sort queries by r\n        indexed=[(r,l,idx) for idx,(l,r) in enumerate(queries)]\n        indexed.sort()\n        bit_sum=BIT(n)\n        bit_cnt=BIT(n)\n        ans=[0]*len(queries)\n        active=[False]*n\n        ptr=0\n        for r,l,idx in indexed:\n            while ptr<=r:\n                for i in byRight[ptr]:\n                    bit_sum.add(i,right[i])\n                    bit_cnt.add(i,1)\n                    active[i]=True\n                ptr+=1\n            total_f=bit_sum.range_sum(l,r)\n            active_cnt=bit_cnt.range_sum(l,r)\n            total_len=r-l+1\n            ans[idx]=total_f + r*(total_len-active_cnt)\n        return ans", "tests_passed": 1, "score": 0.8125}
{"code": "import sys\nfrom collections import defaultdict\n\nclass Fenwick:\n    def __init__(self, n):\n        self.n = n\n        self.bit = [0]*(n+1)\n    def add(self, i, v):\n        i += 1\n        while i <= self.n:\n            self.bit[i] += v\n            i += i & -i\n    def pref(self, i):\n        s = 0\n        i += 1\n        while i>0:\n            s += self.bit[i]\n            i -= i & -i\n        return s\n    def range(self, l, r):\n        if r<l:\n            return 0\n        return self.pref(r)-self.pref(l-1)\n\nclass Solution:\n    def numberOfStableSubarrays(self, nums, queries):\n        n = len(nums)\n        prev = [-1]*n\n        stack = []\n        for i in range(n):\n            while stack and nums[stack[-1]] <= nums[i]:\n                stack.pop()\n            if stack:\n                prev[i] = stack[-1]\n            stack.append(i)\n        f = [i - prev[i] for i in range(n)]\n        key = [prev[i]+1 for i in range(n)]\n        buckets = [[] for _ in range(n+1)]\n        for i in range(n):\n            buckets[key[i]].append(i)\n        queries_by_l = defaultdict(list)\n        for idx,(l,r) in enumerate(queries):\n            queries_by_l[l].append((r,idx))\n        ans = [0]*len(queries)\n        fw_f = Fenwick(n)\n        fw_k = Fenwick(n)\n        fw_c = Fenwick(n)\n        for l in range(n+1):\n            if l in queries_by_l:\n                for r,qi in queries_by_l[l]:\n                    total_f = fw_f.range(l, r)\n                    total_k = fw_k.range(l, r)\n                    total_c = fw_c.range(l, r)\n                    ans[qi] = total_f - (total_c * l - total_k)\n            if l < n:\n                for i in buckets[l+1]:\n                    fw_f.add(i, f[i])\n                    fw_k.add(i, key[i])\n                    fw_c.add(i, 1)\n        return ans\n", "tests_passed": 0, "score": 0.83203125}
{"code": "import sys\nfrom bisect import bisect_left, bisect_right\n\nclass BIT:\n    __slots__ = ('n', 'tree')\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * (n + 1)\n    def add(self, idx, val):\n        i = idx + 1\n        n = self.n\n        tree = self.tree\n        while i <= n:\n            tree[i] += val\n            i += i & -i\n    def sum(self, idx):\n        i = idx + 1\n        res = 0\n        tree = self.tree\n        while i > 0:\n            res += tree[i]\n            i -= i & -i\n        return res\n    def range_sum(self, l, r):\n        return self.sum(r) - (self.sum(l - 1) if l else 0)\n\nclass Solution:\n    def numberOfStableSubarrays(self, nums, queries):\n        n = len(nums)\n        A = [0] * n\n        left = 0\n        for i in range(n):\n            if i == 0 or nums[i] < nums[i - 1]:\n                left = i\n            A[i] =", "tests_passed": 0, "score": 0.82421875}
{"code": "import sys\n\nclass Fenwick:\n    def __init__(self, n):\n        self.n = n\n        self.bit = [0import sys\nclass Fenwick:\n    def __init__(self,n):\n        self.n=n\n        self.bit=[0]*(n+1)\n    def add(self,i,v):\n        i+=1\n        while i<=self.n:\n            self.bit[i]+=v\n            i+=i&-i\n    def sum(self,i):\n        s=0\n        i+=1\n        while i>0:\n            s+=self.bit[i]\n            i-=i&-i\n        return s\n    def range(self,l,r):\n        return self.sum(r)-self.sum(l-1)\nclass Solution:\n    def stableSubarrayCount(self, nums, queries):\n        n=len(nums)\n        len_arr=[0]*n\n        s=[0]*n\n        for i,x in enumerate(nums):\n            if i==0 or nums[i-1]<=x:\n                len_arr[i]=len_arr[i-1]+1\n            else:\n                len_arr[i]=1\n            s[i]=i-len_arr[i]+1\n        pref_i=[0]*(n+1)\n        for i in range(n):\n            pref_i[i+1]=pref_i[i]+i\n        pref_len=[0]*(n+1)\n        for i in range(n):\n            pref_len[i+1]=pref_len[i]+len_arr[i]\n        q=len(queries)\n        ans=[0]*q\n        indexed_q=[(l,r,idx) for idx,(l,r) in enumerate(queries)]\n        indexed_q.sort(key=lambda x:-x[0])\n        order=sorted(range(n), key=lambda i:s[i], reverse=True)\n        ft_val=Fenwick(n)\n        ft_cnt=Fenwick(n)\n        ptr=0\n        for l,r,idx in indexed_q:\n", "tests_passed": 0, "score": 0.82421875}
{"code": "import bisect\n\nclass Solution:\n    def numberOfStableSubarrays(self, nums, queries):\n        n = len(nums)\n        incEnd = [0] * n\n        r = 0\n        for i in range(n):\n            while r + 1 < n and nums[r] <= nums[r + ", "tests_passed": 0, "score": 0.8203125}
{"code": "import sys\nfrom collections import defaultdict\n\nclass Fenwick:\n    __slots__=('n','bit')\n    def __init__(self,n):\n        self.n=n\n        self.bit=[0]*(n+1)\n    def add(self,i,delta):\n        i+=1\n        n=self.n\n        bit=self.bit\n        while i<=n:\n            bit[i]+=delta\n            i+=i&-i\n    def sum(self,i):\n        if i<0:return 0\n        i+=1\n        s=0\n        bit=self.bit\n        while i>0:\n            s+=bit[i]\n            i-=i&-i\n        return s\n    def range_sum(self,l,r):\n        if r<l:return 0\n        return self.sum(r)-self.sum(l-1)\n\nclass Solution:\n    def stableSubarrays(self, nums, queries):\n        n=len(nums)\n        left=[0]*n\n        lastBad=-1\n        for i in range(n):\n            if i>0 and nums[i-1]>nums[i]:\n                lastBad=i-1\n            left[i]=lastBad+1\n        lenArr=[0]*n\n        for i in range(n):\n            lenArr[i]=i-left[i]+1\n        lenFT=Fenwick(n)\n        activeFT=Fenwick(n)\n        countFT=Fenwick(n)\n        for i in range(n):\n            lenFT.add(i,lenArr[i])\n        byL=[[] for _ in range(n)]\n        for idx,(l,r) in enumerate(queries):\n            byL", "tests_passed": 0, "score": 0.8125}
{"code": "import bisect\n\nclass Solution:\n    def numberOfStableSubarrays(self, nums, queries):\n        n = len(nums)\n        dp = [0]*n\n        dp[0] = 1\n        for i in range(1, n):\n            if nums[i-1] <= nums[i]:\n               ", "tests_passed": 0, "score": 0.8125}
{"code": "import sys\nfrom bisect import bisect_left, bisect_right\n\nclass Solution:\n    def numberOfStableSubarrays(self, nums, queries):\n        n = len(nums)\n        start = [0]*n\n        for i in range(1, n):\n            if nums[i] < nums[i-1]:\n                start[i] = i\n            else:\n               ", "tests_passed": 0, "score": 0.80859375}
{"code": "import sys\nfrom typing import List\n\nclass Solution:\n    def numStableSubarrays(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(nums)\n        block_id = [0] * n\n        block_start = []\n        block_end = []\n        block_len = []\n        block_contrib = []\n\n        current_start = 0\n        current_id = 0\n        block_start.append(0)\n\n        for i in range(1, n):\n            if nums[i - 1] > nums[i]:\n                block_end.append(i - 1)\n                length = i - 1 - block_start[current_id] + 1\n                block_len.append(length)\n                block_contrib.append(length * (length + 1) // 2)\n                current_start = i\n                current_id += 1\n                block_start.append(i)\n            block_id[i] = current_id\n\n        # finalize last block\n        block_end.append(n - 1)\n        length = n - 1 - block_start[current_id] + 1\n        block_len.append(length)\n        block_contrib.append(length * (length + 1) // 2)\n\n        # prefix sums of full block contributions\n        pref_block = [0] * len(block_contrib)\n        pref_block[0] = block_contrib[0]\n        for i in range(1, len(block_contrib)):\n            pref_block[i] = pref_block[i - 1] + block_contrib[i]\n\n        ans = []\n        for l, r in queries:\n            b_l = block_id[l]\n            b_r = block_id[r]\n            if b_l == b_r:\n                x = r - l + 1\n                ans.append(x * (x + 1) // 2)\n            else:\n                left_len = block_end[b_l] - l + 1\n                left_contrib = left_len * (left_len + 1) // 2\n                right_len = r - block_start[b_r] + 1\n                right_contrib = right_len * (right_len + 1) // 2\n                middle_con", "tests_passed": 0, "score": 0.8046875}
{"code": "import sys\nfrom bisect import bisect_left\n\nclass BIT:\n    def __init__(self, n):\n        self.n = n\n        self.bit = [0] * (n + 2)\n    def add(self, idx, val):\n        i = idx\n        n = self.n + 1\n        while i <= n:\n            self.bit[i] += val\n            i += i & -i\n    def query(self, idx):\n        i = idx\n        s = 0\n        while i > 0:\n            s += self.bit[i]\n            i -= i & -i\n        return s\n    def range_query(self, l, r):\n        if r < l:\n            return 0\n        return self.query(r) - self.query(l - 1)\n\nclass Solution:\n    def countStableSubarrays(self, nums, queries):\n        n = len(nums)\n        leftLimit = [0] * n\n        lastBreak = -1\n        for i in range(n):\n            if i > 0 and nums[i - 1] > nums[i]:\n                lastBreak = i - 1\n            leftLimit[i] = lastBreak + 1\n        len_full = [0] * n\n        for i in range(n):\n            len_full[i] = i - leftLimit[i] + 1\n        pref = [0] * (n + 1)\n        for i in range(n):\n            pref[i + 1] = pref[i] + len_full[i]\n        items = sorted([(leftLimit[i], i) for i in range(n)])\n        bitCnt = BIT(n)\n        bitSum = BIT(n)\n        ptr = 0\n        qs = sorted([(l, r, idx) for idx, (l, r) in enumerate(queries)])\n        ans = [0] * len(queries)\n        for l, r, qi in qs:\n            while ptr < n and items[ptr][0] < l:\n                val, pos = items[ptr]\n                bitCnt.add(pos +import sys\nfrom collections import defaultdict\n\nclass Fenwick:\n    def __init__(self, n):\n        self.n = n\n        self.bit = [0] * (n + 1)\n    def add(self, i, delta):\n        i += 1\n        while i <= self.n:\n            self.bit[i] += delta\n            i += i & -i\n    def sum(self, i):\n        res = 0\n        i += 1\n        while i > 0:\n            res += self.bit[i]\n            i -= i & -i\n        return res\n    def range_sum(self, l, r):\n        if r < l:\n            return 0\n        return self.sum(r) - (self.sum(l - 1) if l else 0)\n\nclass Solution:\n    def countStableSubarrays(self, nums, queries):\n        n = len(nums)\n        next_smaller = [n] * n\n        stack = []\n        for i in range(n - 1, -1, -1):\n            while stack and nums[stack[-1]] >= nums[i]:\n                stack.pop()\n            next_smaller[i] = stack[-1] if stack else n\n            stack.append(i)\n        extra = [next_smaller[i] - 1 for i in range(n)]\n        base = [extra[i] - i + 1 for i in range(n)]\n        S = [0] * n\n        s = 0\n        for i in range(n):\n            s += base[i]\n            S[i] = s\n        pos_by_val = defaultdict(list)\n        for i, v in enumerate(extra):\n            pos_by_val[v].append(i)\n        fen_count = Fenwick(n)\n        fen_sum = Fenwick(n)\n        for i, v in enumerate(extra):\n            fen_count.add(i, 1)\n            fen_sum.add(i, v)\n        indexed_queries = []\n        for idx, (l, r) in enumerate(queries):\n            indexed_queries.append((r, l, idx))\n        indexed_queries.sort()\n        ans = [0] * len(queries)\n        processed_r = -1\n        for r, l, qi in indexed_queries:\n            while processed_r < r:\n                processed_r += 1\n                for idx in pos_by_val.get(processed_r, []):\n                    fen_count.add(idx, -1)\n                    fen_sum.add(idx, -processed_r)\n            sum_base = S[r] - (S[l - 1] if l else 0)\n            cnt = fen_count.range_sum(l, r)\n            sum_ex = fen_sum.range_sum(l, r)\n            ans[qi] = sum_base - (sum_ex - r * cnt)\n        return ans\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.countStableSubarrays([3,1,2], [[0,1],[1,2],[0,2]]))\n    print(sol.countStableSubarrays([2,2], [[0,1],[0,0]]))\n    print(sol.countStableSubarrays([8,12], [[1,1]]))", "tests_passed": 0, "score": 0.8046875}
{"code": "import sys\n\nclass Solution:\n    def countStableSubarrays(self, nums, queries):\n        n = len(nums)\n        leftRun = [0]*n\n        for i in range(1,n):\n            if nums[i-1] > nums[i]:\n                leftRun[i] = i\n            else:\n                leftRun[i] = leftRun[i-1]\n        # preSum1\n        preSum1 = [0]*n\n        for i in range(n):\n            val = i - leftRun[i] + 1\n            preSum1[i] = val + (preSum1[i-1] if i>0 else 0)\n        # build runs mapping start -> indices\n        runs_map = {}\n        for i in range(n):\n            s = leftRun[i]\n            runs_map.setdefault(s, []).append(i)\n        # Fenwick trees\n        size = n+2\n        bitCnt = [0]*size\n        bitSum = [0]*size\n        def bit_update(bit, idx, delta):\n            i = idx+1\n            while i < size:\n                bit[i] += delta\n                i += i & -i\n        def bit_query(bit, idx):\n            res = 0\n            i = idx+1\n            while i>0:\n                res += bit[i]\n                i -= i & -i\n            return res\n        def bit_range(bit, l, r):\n            return bit_query(bit, r) - (bit_query(bit, l-1) if l>0 else 0)\n        # process queries sorted by l\n        qn = len(queries)\n        qs = [(l,r,i) for i,(l,r) in enumerate(queries)]\n        qs.sort()\n        res = [0]*qn\n        curr_start = 0\n        for l,r,idx in qs:\n            while curr_start < l:\n                for pos in runs_map.get(curr_start, []):\n                    bit_update(bitCnt, pos, 1)\n                    bit_update(bitSum, pos, curr_start)\n                curr_start += 1\n            # sum1\n            sum1 = preSum1[r] - (preSum1[l-1] if l>0 else 0)\n            # extra\n            count = bit_range(bitCnt, l, r)\n            sum_left = bit_range(bitSum, l, r)\n            extra = l*count - sum_left\n            res[idx] = sum1 - extra\n        return res\nif __name__==\"__main__\":\n    sol=Solution()\n    print(sol.countStableSubarrays([3,1,2], [[0,1],[1,2],[0,2]]))\n    print(sol.countStableSubarrays([2,2], [[0,1],[0,0]]))\n    print(sol.countStableSub", "tests_passed": 0, "score": 0.796875}
{"code": "import sys\n\nclass Solution:\n    def stableSubarrays(self, nums, queries):\n        n = len(nums)\n        endRun = [0]*n\n        endRun[-1] = n-1\n        for i in range(n-2, -1, -1):\n            if nums[i] <= nums[i+1]:\n                endRun[i] = endRun[i+1]\n            else:\n                endRun[i] = i\n        class Fenwick:\n            __slots__ = (\"n\",\"bit\")\n            def __init__(self,n):\n                self.n=n\n                self.bit=[0]*(n+1)\n            def add(self,i,v):\n                i+=1\n                n=self.n+1\n                bit=self.bit\n                while i<n:\n                    bit[i]+=v\n                    i+=i&-i\n            def sum(self,i):\n                i+=1\n                s=0\n                bit=self.bit\n                while i>0:\n                    s+=bit[i]\n                    i-=i&-i\n                return s\n        fenLin=Fenwick(n)\n        fenConst=Fenwick(n)\n        events=[[] for _ in range(n+1)]\n        for i in range(n):\n            fenLin.add(i,1)\n            fenConst.add(i,1-i)\n            if endRun[i]+1<=n:\n                events[endRun[i]+1].append((i,endRun[i]-1))\n        q=len(queries)\n        ans=[0]*q\n        sorted_q=sorted([(queries[i][1],queries[i][0],i) for i in range(q)])\n        cur=0\n        for r,l,idx in sorted_q:\n            while cur<=r:\n                for i,delta in events[cur]:\n                    fenLin.add(i,-1)\n                    fenConst.add(i,delta)\n                cur+=1\n            sumLin=fenLin.sum(r)-fenLin.sum(l-1) if l>0 else fenLin.sum(r)\n            sumConst=fenConst.sum(r)-fenConst.sum(l-1) if l>0 else fenConst.sum(r)\n            ans[idx]=sumLin*r+sumConst\n        return ans\nif __name__==\"__import sys\nfrom bisect import bisect_left, bisect_right\n\nclass Solution:\n    def numberOfStableSubarrays(self, nums, queries):\n        n = len(nums)\n        prev = [-1]*n\n        stack = []\n        for i, val in enumerate(nums):\n            while stack and nums[stack[-1]] <= val:\n                stack.pop()\n            if stack:\n                prev[i] = stack[-1]\n            stack.append(i)\n        leftBound = [p+1 for p in prev]\n        bound_pairs = sorted([(leftBound[i], i) for i in range(n)])\n        qcnt = len(queries)\n        qs = [(l, r, idx) for idx,(l,r) in enumerate(queries)]\n        qs.sort(key=lambda x:x[0])\n        size = n+2\n        bit_cnt = [0]*size\n        bit_sum = [0]*size\n        def bit_add(bit, pos, val):\n            pos +=1\n            while pos < size:\n                bit[pos] += val\n                pos += pos & -pos\n        def bit_sum_query(bit, pos):\n            res = 0\n            pos +=1\n            while pos>0:\n                res += bit[pos]\n                pos -= pos & -pos\n            return res\n        for i in range(n):\n            bit_add(bit_cnt, i, 1)\n            bit_add(bit_sum, i, leftBound[i])\n        ptr = 0\n        ans = [0]*qcnt\n        for l,r,idx in qs:\n            while ptr < n and bound_pairs[ptr][0] <= l:\n                lb, pos = bound_pairs[ptr]\n                bit_add(bit_cnt, pos, -1)\n                bit_add(bit_sum, pos, -lb)\n                ptr +=1\n            cnt = bit_sum_query(bit_cnt, r) - bit_sum_query(bit_cnt, l-1)\n            sm = bit_sum_query(bit_sum, r) - bit_sum_query(bit_sum, l-1)\n            total_i1 = (r*(r+1)//2) - ((l-1)*l//2)\n            ans[idx] = total_i1 - l*(r-l+1) - (sm - l*cnt)\n        return ans\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.numberOfStableSubarrays([3,1,2],[[0,1],[1,2],[0,2]]))\n    print(sol.numberOfStableSubarrays([2,2],[[0,1],[0,0]]))\n    print(sol.numberOfStableSubarrays([", "tests_passed": 0, "score": 0.7890625}
{"code": "import sys\n\nclass Solution:\n    def numberOfStableSubarrays(self, nums, queries):\n        n = len(nums)\n        start = [0]*n\n        for i in range(1,n):\n            start[i] = i if nums[i] < nums[i-1] else start[i-1]\n        prefA = [0]*n\n        for i in range(n):\n            val = i - start[i] + 1\n            prefA[i] = val + (prefA[i-1] if i>0 else 0)\n        class BIT:\n            def __init__(import bisect\nclass Solution:\n    def countStableSubarrays(self, nums, queries):\n        n = len(nums)\n        left = [0]*n\n        left[0] = 0\n        for i in range(1,n):\n            if nums[i] >= nums[i-1]:\n                left[i] = left[i-1]\n            else:\n                left[i] = i\n        # prefix sums\n        prefJ = [0]*(n+1)\n        prefLB = [0]*(n+1)\n        for i in range(n):\n            prefJ[i+1] = prefJ[i] + (i+1)\n            prefLB[i+1] = prefLB[i] + left[i]\n        # segment tree\n        size = 1\n        while size < n: size <<=1\n        seg_vals = [[] for _ in range(2*size)]\n        seg_pref = [[] for _ in range(2*size)]\n        for i in range(n):\n            seg_vals[size+i] = [left[i]]\n            seg_pref[size+i] = [left[i]]\n        for i in range(size-1,0,-1):\n            left_list = seg_vals[2*i]+seg_vals[2*i+1]\n            left_list.sort()\n            seg_vals[i] = left_list\n            pref = []\n            s=0\n            for v in left_list:\n                s+=v\n                pref.append(s)\n            seg_pref[i] = pref\n        def query(l,r):\n            cnt_lt = 0\n            sum_lt = 0\n            l += size\n            r += size+1\n            while l<r:\n                if l&1:\n                    idx = bisect.bisect_left(seg_vals[l], l)\n                    cnt_lt += idx\n                    sum_lt += seg_pref[l][idx-1] if idx>0 else 0\n                    l+=1\n                if r&1:\n                    r-=1\n                    idx = bisect.bisect_left(seg_vals[r], l)\n                    cnt_lt += idx\n                    sum_lt += seg_pref[r][idx-1] if idx>0 else 0\n                l//=2; r//=2\n            return cnt_lt, sum_lt\n        ans=[]\n        for L,R in queries:\n            total_j = prefJ[R+1]-prefJ[L]\n            total_sumLB = prefLB[R+1]-prefLB[L]\n            cnt_lt, sum_lt = query(L,R)\n            sum_ge = total_sumLB - sum_lt\n            S2 = L*cnt_lt + sum_ge\n            ans.append(total_j - S2)\n        return ans", "tests_passed": 0, "score": 0.7734375}
