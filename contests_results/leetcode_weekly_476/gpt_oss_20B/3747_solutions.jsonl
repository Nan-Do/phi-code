{"code": "import sys\n\nclass Solution:\n    def countNumbersWithoutZero(self, n: int) -> int:\n        s = str(n)\n        L = len(s)\n        from functools import lru_cache\n\n        @lru_cache(None)\n        def dfs(pos, tight, started):\n            if pos == L:\n                return 1 if started else 0\n            limit = int(s[pos]) if tight else 9\n            res = 0\n            for d in range(0, limit + 1):\n                ntight = tight and d == limit\n                nstarted = started or d != 0\n                if not nstarted:\n                    # still leading zeros, d must be 0\n                    res += dfs(pos + 1, ntight, False)\n                else:\n                    if d == 0:\n                        continue\n                    res += dfs(pos + 1, ntight, True)\n            return res\n\n        return dfs(0, True, False)\n\n    def solve(self, n: int) -> int:\n        return self.countNumbersWithoutZero(n)\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.solve(10))", "tests_passed": 2, "score": 0.73828125}
{"code": "import sys\n\nclass Solution:\n    def countDistinct(self, n: int) -> int:\n        s = str(n)\n        L = len(s)\n        pow9 = [1] * (L + 1)\n        for i in range(1, L + 1):\n            pow9[i] = pow9[i - 1] * 9\n        ans = 0\n        for l in range(1, L):\n            ans += pow9[l]\n        tight = True\n        for i, ch in enumerate(s):\n            cur = int(ch)\n            remaining = L - i - 1\n            if not tight:\n                ans += 9 ** remaining\n                continue\n            if cur == 0:\n                break\n            less = cur - 1\n            if less > 9:\n                less = 9\n            if less > 0:\n                ans += less * pow9[remaining]\n            if cur < 1 or cur > 9:\n                break\n            if i == L - 1:\n                ans += 1\n        return ans\nif __name__ == \"__main__\":\n    print(Solution().countDistinct(10))", "tests_passed": 2, "score": 0.734375}
{"code": "import sys\nclass Solution:\n    def countNonZero(self, n: int) -> int:\n        s = str(n)\n        L = len(s)\n        from functools import lru_cache\n        @lru_cache(maxsize=None)\n        def dp(pos, tight, started):\n            if pos == L:\n                return 1 if started else 0\n            limit = int(s[pos]) if tight else 9\n            total = 0\n            for d in range(0, limit+1):\n                ntight = tight and (d == limit)\n                if not started:\n                    if d == 0:\n                        total += dp(pos+1, ntight, False)\n                    else:\n                        total += dp(pos+1, ntight, True)\n                else:\n                    if d == 0:\n                        continue\n                    total += dp(pos+1, ntight, True)\n            return total\n        return dp(0, True, False)\n    def numberOfDistinctIntegers(self, n: int) -> int:\n        return self.countNonZero(n)\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.numberOfDistinctIntegers(10))\n    print(sol.numberOfDistinctIntegers(3))\n    print(sol.numberOfDistinctIntegers(100))", "tests_passed": 2, "score": 0.73046875}
{"code": "import sys\nfrom functools import lru_cache\n\nclass Solution:\n    def distinctNumbers(self, n: int) -> int:\n        s = str(n)\n        L = len(s)\n\n        @lru_cache(None)\n        def dfs(pos: int, tight: bool, started: bool) -> int:\n            if pos == L:\n                return 1 if started else 0\n            limit = int(s[pos]) if tight else 9\n            total = 0\n            for d in range(0, limit + 1):\n                ntight = tight and d == limit\n                nstarted = started or d != 0\n                if d == 0 and not nstarted:\n                    # leading zero allowed\n                    total += dfs(pos + 1, ntight, nstarted)\n                elif d == 0:\n                    continue  # zero after start not allowed\n                else:\n                    total += dfs(pos + 1, ntight, nstarted)\n            return total\n\n        return dfs(0, True, False) + (1 if n == 0 else 0)  # add zero? no\n\n# The above implementation counts numbers from 1 to n with no zero digits.", "tests_passed": 2, "score": 0.73046875}
{"code": "import sys\n\nclass Solution:\n    def distinctIntegers(self, n: int) -> int:\n        digits = list(map(int, str(n)))\n        L = len(digits := digits)\n        pow9 = [1] * (L + 1)\n        for i in range(1, L + 1):\n            pow9[i] = pow9[i - 1] * 9\n        total = 0\n        for l in range(1, L):\n            total += pow9[l]\n        tight = True\n        for i in range(L):\n            cur = digits[i]\n            if cur == 0:\n                break\n            start = 1 if i == 0 else 1\n            for d in range(start, cur):\n                total += pow9[L - i - 1]\n            if cur == 0:\n                break\n        else:\n            total += 1\n        return total", "tests_passed": 2, "score": 0.72265625}
{"code": "import sys\n\nclass Solution:\n    def numberOfDistinct(self, n: int) -> int:\n        digits = list(map(int, str(n)))\n        L = len(digits)\n        total = 0\n        pow9 = 1\n        for l in range(1, L):\n            pow9 *= 9\n            total += pow9\n        # DP for length L\n        dp = [0, 0]  # dp[tight]\n        dp[1] = 1\n        for pos in range(L):\n            ndp = [0, 0]\n            limit = digits[pos]\n            for tight in (0, 1):\n                if dp[tight] == 0:\n                    continue\n                max_digit = limit if tight else 9\n                for d in range(1, max_digit + 1):\n                    if d == 0:\n                        continue\n                    ntight = tight and d == max_digit\n                    ndp[ntight] += dp[tight]\n            dp = ndp\n        total += dp[0] + dp[1]\n        return total\nif __name__ == \"__main__\":\n    print(Solution().numberOfDistinct(10))\n    print(Solution().numberOfDistinct(3))", "tests_passed": 2, "score": 0.72265625}
{"code": "import sys\nfrom typing import List\n\nclass Solution:\n    def distinctIntegers(self, n: int) -> int:\n        digits: List[int] = list(map(int, str(n)))\n        L: int = len(digits := digits)\n        pow9: List[int] = [1] * (L + 1)\n        for i in range(1, L + 1):\n            pow9[i] = pow9[i - 1] * 9\n        res = 0\n        for l in range(1, L):\n            res += pow9[l]\n        for i, d in enumerate(digits):\n            if d == 0:\n                break\n            if i == 0:\n                for d0 in range(1, d):\n                    res += pow9[L - i - 1]\n            else:\n                for d0 in range(1, d):\n                    res += pow9[L - i - 1]\n        else:\n            res += 1\n        return res\n", "tests_passed": 2, "score": 0.72265625}
{"code": "import sys\n\nclass Solution:\n    def distinctNumbers(self, n: int) -> int:\n        digits = list(map(int, str(n)))\n        L = len(digits := digits)\n        pow9 = [1] * (L + 1)\n        for i in range(1, L + 1):\n            pow9[i] = pow9[i - 1] * 9\n        ans = 0\n        for l in range(1, L):\n            ans += pow9[l]\n        for i, d in enumerate(digits):\n            if d == 0:\n                break\n            remaining = L - i - 1\n            ans += (d - 1) * pow9[remaining]\n            if i == L - 1 and d != 0:\n                ans += 1\n        return ans\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.distinctNumbers(10))\n    print(sol.distinctNumbers(3))\n    print(sol.distinctNumbers(100))", "tests_passed": 2, "score": 0.71875}
{"code": "import sys\n\nclass Solution:\n    def countNumbers(self, n: int) -> int:\n        s = str(n)\n        l = len(s)\n        total = 0\n        # count numbers with fewer digits\n        for length in range(1, l):\n            total += 9 ** length\n        # count numbers with same length\n        for i, ch in enumerate(s):\n            cur = int(ch)\n            for d in range(1, cur):\n                total += 9 ** (l - i - 1)\n            if cur == 0:\n                return total\n        total += 1  # n itself has no zeros\n        return total\n", "tests_passed": 2, "score": 0.71875}
{"code": "import sys\n\nclass Solution:\n    def numDistinctIntegers(self, n: int) -> int:\n        digits = list(map(int, str(n)))\n        length = len(digits := digits)\n        pow9 = [1] * (length + 1)\n        for i in range(1, length + 1):\n            pow9[i] = pow9[i - 1] * 9\n        count = 0\n        for k in range(1, length):\n            count += pow9[k]\n        for i, d in enumerate(digits):\n            remaining = length - i - 1\n            if d == 0:\n                break\n            for c in range(1, 10):\n                if c < d:\n                    count += pow9[remaining]\n            else:\n                continue\n            break\n        else:\n            count += 1\n        return count\n", "tests_passed": 2, "score": 0.71875}
{"code": "import sys\n\nclass Solution:\n    def distinctIntegers(self, n: int) -> int:\n        s = str(n)\n        L = len(s)\n        pow9 = [1] * (L + 1)\n        for i in range(1, L + 1):\n            pow9[i] = pow9[i - 1] * 9\n        count = 0\n        for l in range(1, L):\n            count += pow9[l]\n        prefix_ok = True\n        for i, ch in enumerate(s):\n            d = int(ch)\n            for c in range(1, d):\n                if prefix_ok:\n                    count += pow9[L - i - 1]\n            if d == 0:\n                prefix_ok = False\n                break\n            else:\n                continue\n        if prefix_ok:\n            count += 1\n        return count\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.distinctIntegers(10))\n    print(sol.distinctIntegers(3))", "tests_passed": 2, "score": 0.7109375}
{"code": "import sys\nfrom typing import *\n\nclass Solution:\n    def countDistinct(self, n: int) -> int:\n        digits = list(map(int, str(n)))\n        L = len(digits)\n        ans = 0\n        pow9 = 1\n        for l in range(1, L):\n            pow9 *= 9\n            ans += pow9\n        dp = [[0, 0] for _ in range(L+1)]\n        dp[0][1] = 1\n        for i in range(L):\n            limit = digits[i]\n            for tight in (0, 1):\n                cur = dp[i][tight]\n                if cur == 0:\n                    continue\n                max_digit = limit if tight else 9\n                for d in range(1, max_digit+1):\n                    ntight = tight and d == limit\n                    dp[i+1][ntight] += cur\n        ans += dp[L][0] + dp[L][1]\n        return ans", "tests_passed": 2, "score": 0.7109375}
{"code": "import sys\n\nclass Solution:\n    def countDistinct(self, n: int) -> int:\n        digits = list(map(int, str(n)))\n        from functools import lru_cache\n\n        @lru_cache(None)\n        def dfs(pos, tight, started):\n            if pos == len(digits):\n                return int(started)\n            limit = digits[pos] if tight else 9\n            res = 0\n            for d in range(0, limit + 1):\n                ntight = tight and (d == limit)\n                if not started:\n                    if d == 0:\n                        res += dfs(pos + 1, ntight, 0)\n                    else:\n                        if d != 0:\n                            res += dfs(pos + 1, ntight, 1)\n                else:\n                    if d == 0:\n                        continue\n                    res += dfs(pos + 1, ntight, 1)\n            return res\n\n        digits = digits\n        return dfs(0, True, False)\nif __name__ == \"__main__\":\n    print(Solution().countDistinct(10))\n", "tests_passed": 2, "score": 0.7109375}
{"code": "import sys\nclass Solution:\n    def distinctIntegers(self, n: int) -> int:\n        s = str(n)\n        L = len(s)\n        pow9 = [1] * (L + 1)\n        for i in range(1, L + 1):\n            pow9[i] = pow9[i - 1] * 9\n        ans = 0\n        for l in range(1, L):\n            ans += pow9[l]\n        for i, ch in enumerate(s):\n            cur = int(ch)\n            if cur == 0:\n                return ans\n            for d in range(1, cur):\n                ans += pow9[L - i - 1]\n            if cur == 0:\n                return ans\n        ans += 1\n        return ans\n\nif __name__ == \"__main__\":\n    sys.setrecursionlimit(10**6)", "tests_passed": 2, "score": 0.7109375}
{"code": "import sys\nclass Solution:\n    def countDistinct(self, n: int) -> int:\n        s = str(n)\n        L = len(s)\n        pow9 = [1] * (L + 1)\n        for i in range(1, L + 1):\n            pow9[i] = pow9[i - 1] * 9\n        ans = 0\n        for l in range(1, L):\n            ans += pow9[l]\n        for i, ch in enumerate(s):\n            digit = int(ch)\n            if digit == 0:\n                break\n            for d in range(1, digit):\n                ans += pow9[L - i - 1]\n            if i == L - 1:\n                ans += 1\n        return ans", "tests_passed": 2, "score": 0.70703125}
{"code": "import sys\nsys.setrecursionlimit(1 << 25)\n\nclass Solution:\n    def distinctIntegers(self, n: int) -> int:\n        s = str(n)\n        digits = list(map(int, s))\n        from functools import lru_cache\n\n        @lru_cache(None)\n        def dp(pos: int, tight: bool, started: bool) -> int:\n            if pos == len(digits):\n                return 1 if started else 0\n            limit = digits[pos] if tight else 9\n            total = 0\n            for d in range(0, limit + 1):\n                ntight = tight and (d == limit)\n                if started:\n                    if d == 0:\n                        continue\n                else:\n                    if d == 0:\n                        total += dp(pos + 1, ntight, False)\n                        continue\n                total += dp(pos + 1, ntight, True)\n            return total\n\n        return dp(0, True, False)", "tests_passed": 2, "score": 0.70703125}
{"code": "import sys\n\nclass Solution:\n    def distinctIntegers(self, n: int) -> int:\n        s = str(n)\n        m = len(s)\n        from functools import lru_cache\n        @lru_cache(None)\n        def dp(pos, tight, started):\n            if pos == m:\n                return 1 if started else 0\n            limit = int(s[pos]) if tight else 9\n            res = 0\n            for d in range(0, limit + 1):\n                ntight = tight and d == limit\n                if not started:\n                    if d == 0:\n                        res += dp(pos + 1, ntight, False)\n                    else:\n                        res += dp(pos + 1, ntight, True)\n                else:\n                    if d == 0:\n                        continue\n                    res += dp(pos + 1, ntight, True)\n            return res\n        return dp(0, True, False)", "tests_passed": 2, "score": 0.70703125}
{"code": "import sys\nfrom functools import lru_cache\n\nclass Solution:\n    def distinctIntegers(self, n: int) -> int:\n        s = str(n)\n        @lru_cache(None)\n        def dfs(pos, tight, started):\n            if pos == len(s):\n                return 1 if started else 0\n            limit = int(s[pos]) if tight else 9\n            total = 0\n            for d in range(0, limit+1):\n                ntight = tight and d == limit\n                nstarted = started or d != 0\n                if nstarted and d == 0:\n                    continue\n                total += dfs(pos+1, ntight, nstarted)\n            return total\n        return dfs(0, True, False)", "tests_passed": 2, "score": 0.70703125}
{"code": "import sys\nsys.setrecursionlimit(1 << 25)\n\nclass Solution:\n    def distinctNumbers(self, n: int) -> int:\n        s = str(n)\n        from functools import lru_cache\n        @lru_cache(None)\n        def dfs(idx: int, tight: bool, started: bool) -> int:\n            if idx == len(s):\n                return 1 if started else 0\n            limit = int(s[idx]) if tight else 9\n            total = 0\n            for d in range(limit + 1):\n                ntight = tight and d == limit\n                nstarted = started or d != 0\n                if nstarted and d == 0:\n                    continue\n                total += dfs(idx + 1, ntight, nstarted)\n            return total\n        return dfs(0, True, False)", "tests_passed": 2, "score": 0.70703125}
{"code": "import sys\nclass Solution:\n    def countZeroFree(self, n: int) -> int:\n        s = str(n)\n        L = len(s)\n        pow9 = [1] * (L + 1)\n        for i in range(1, L + 1):\n            pow9[i] = pow9[i - 1] * 9\n        res = 0\n        for l in range(1, L):\n            res += pow9[l]\n        for i, ch in enumerate(s):\n            d = ord(ch) - 48\n            if d == 0:\n                break\n            less = d - 1\n            res += less * pow9[L - i - 1]\n            if i == L - 1:\n                res += 1\n        return res\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.countZeroFree(10))\n    print(sol.countZeroFree(3))", "tests_passed": 2, "score": 0.703125}
{"code": "import sys\nfrom functools import lru_cache\n\nclass Solution:\n    def distinctIntegers(self, n: int) -> int:\n        s = str(n)\n        L = len(s)\n        @lru_cache(None)\n        def dfs(pos, tight, started):\n            if pos == L:\n                return 1 if started else 0\n            limit = int(s[pos]) if tight else 9\n            res = 0\n            for d in range(0, limit + 1):\n                ntight = tight and (d == limit)\n                if not started:\n                    if d == 0:\n                        res += dfs(pos + 1, ntight, False)\n                    else:\n                        res += dfs(pos + 1, ntight, True)\n                else:\n                    if d == 0:\n                        continue\n                    res += dfs(pos + 1, ntight, True)\n            return res\n        return dfs(0, True, False)\n", "tests_passed": 2, "score": 0.69921875}
{"code": "import sys\nfrom functools import lru_cache\n\nclass Solution:\n    def distinctNumbers(self, n: int) -> int:\n        s = str(n)\n        digits = list(map(int, s))\n        L = len(digits := digits)\n\n        @lru_cache(None)\n        def dfs(pos, tight, started):\n            if pos == L:\n                return 1 if started else 0\n            max_digit = digits[pos] if tight else 9\n            total = 0\n            for d in range(max_digit + 1):\n                n_started = started or d != 0\n                if n_started and d == 0:\n                    continue\n                n_tight = tight and d == max_digit\n                total += dfs(pos + 1, n_tight, n_started)\n            return total\n\n        return dfs(0, True, False) if n > 0 else 0\n", "tests_passed": 2, "score": 0.6953125}
{"code": "import sys\nsys.setrecursionlimit(10**6)\n\nclass Solution:\n    def countDistinctIntegers(self, n: int) -> int:\n        digits = list(map(int, str(n)))\n        from functools import lru_cache\n        L = len(digits := digits)\n        @lru_cache(None)\n        def dfs(pos: int, tight: bool, leading: bool) -> int:\n            if pos == L:\n                return 0 if leading else 1\n            limit = digits[pos] if tight else 9\n            total = 0\n            for d in range(0, limit + 1):\n                ntight = tight and d == limit\n                nlead = leading and d == 0\n                if d == 0 and not leading:\n                    continue\n                total += dfs(pos + 1, ntight, nlead)\n            return total\n        return dfs(0, True, True)\n\n# Example usage:\n# sol = Solution()\n# print(sol.countDistinctIntegers(10))  # Output: 9\n# print(sol.countDistinctIntegers(3))   # Output: 3", "tests_passed": 2, "score": 0.6953125}
{"code": "import sys\nsys.setrecursionlimit(1 << 25)\n\nclass Solution:\n    def distinctIntegers(self, n: int) -> int:\n        digits = list(map(int, str(n)))\n        from functools import lru_cache\n\n        @lru_cache(None)\n        def dfs(pos: int, tight: bool, started: bool) -> int:\n            if pos == len(digits):\n                return 1 if started else 0\n            limit = digits[pos] if tight else 9\n            total = 0\n            for d in range(0, limit + 1):\n                ntight = tight and d == limit\n                if not started:\n                    if d == 0:\n                        total += dfs(pos + 1, ntight, False)\n                    else:\n                        total += dfs(pos + 1, ntight, True)\n                else:\n                    if d == 0:\n                        continue\n                    total += dfs(pos + 1, ntight, True)\n            return total\n        return dfs(0, True, False)", "tests_passed": 2, "score": 0.6953125}
{"code": "import sys\nclass Solution:\n    def distinctNumbers(self, n: int) -> int:\n        s = str(n)\n        digits = list(map(int, s))\n        from functools import lru_cache\n        @lru_cache(None)\n        def dfs(pos, tight, started):\n            if pos == len(digits):\n                return 1 if started else 0\n            limit = digits[pos] if tight else 9\n            res = 0\n            for d in range(0, limit + 1):\n                ntight = tight and d == limit\n                nstarted = started or d != 0\n                if not nstarted:\n                    res += dfs(pos + 1, ntight, nstarted)\n                else:\n                    if d == 0:\n                        continue\n                    res += dfs(pos + 1, ntight, nstarted)\n            return res\n        return dfs(0, True, False)", "tests_passed": 2, "score": 0.6953125}
{"code": "import sys\n\nclass Solution:\n    def number(self, n: int) -> int:\n        digits = list(map(int, str(n)))\n        from functools import lru_cache\n        @lru_cache(None)\n        def dfs(pos: int, tight: bool, started: bool) -> int:\n            if pos == len(digits):\n                return 1 if started else 0\n            limit = digits[pos] if tight else 9\n            ans = 0\n            for d in range(limit + 1):\n                new_started = started or d != 0\n                new_tight = tight and d == limit\n                if new_started and d == 0:\n                    continue\n                ans += dfs(pos + 1, new_tight, new_started)\n            return ans\n        return dfs(0, True, False)\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.number(10))\n    print(sol.number(3))\n    print(sol.number(100))\n    print(sol.number(101))\n    print(sol.number(999))\n    print(sol.number(1000))\n    print(sol.number(123456789123456))", "tests_passed": 2, "score": 0.6953125}
{"code": "import sys\nfrom functools import lru_cache\n\nclass Solution:\n    def numberOfDistinctIntegers(self, n: int) -> int:\n        digits = list(map(int, str(n)))\n        L = len(digits := digits)\n        @lru_cache(None)\n        def dfs(pos, tight, started):\n            if pos == L:\n                return 1 if started else 0\n            limit = digits[pos] if tight else 9\n            total = 0\n            for d in range(0, limit + 1):\n                ntight = tight and (d == limit)\n                if not started:\n                    if d == 0:\n                        total += dfs(pos + 1, ntight, False)\n                    else:\n                        total += dfs(pos + 1, ntight, True)\n                else:\n                    if d == 0:\n                        continue\n                    total += dfs(pos + 1, ntight, True)\n            return total\n        return dfs(0, True, False)", "tests_passed": 2, "score": 0.69140625}
{"code": "import sys\nclass Solution:\n    def countNumbersWithoutZero(self, n: int) -> int:\n        s = str(n)\n        L = len(s)\n        sys.setrecursionlimit(10000)\n        from functools import lru_cache\n        @lru_cache(None)\n        def dfs(pos, tight, started):\n            if pos == L:\n                return 1 if started else 0\n            limit = int(s[pos]) if tight else 9\n            total = 0\n            for d in range(0, limit+1):\n                ntight = tight and d == limit\n                nstarted = started or d != 0\n                if nstarted and d == 0:\n                    continue\n                total += dfs(pos+1, ntight, nstarted)\n            return total\n        return dfs(0, True, False)", "tests_passed": 2, "score": 0.69140625}
{"code": "import sys\nfrom functools import lru_cache\n\nclass Solution:\n    def countNumbersWithoutZeros(self, n: int) -> int:\n        digits = list(map(int, str(n)))\n        L = len(digits)\n\n        @lru_cache(None)\n        def dfs(idx, tight, started):\n            if idx == L:\n                return 1 if started else 0\n            limit = digits[idx] if tight else 9\n            res = 0\n            for d in range(0, limit + 1):\n                ntight = tight and d == limit\n                if not started and d == 0:\n                    res += dfs(idx + 1, ntight, False)\n                else:\n                    if d == 0:\n                        continue\n                    res += dfs(idx + 1, ntight, True)\n            return res\n\n        return dfs(0, True, False)\n", "tests_passed": 2, "score": 0.69140625}
{"code": "import sys\n\nclass Solution:\n    def countDistinct(self, n: int) -> int:\n        digits = list(map(int, str(n)))\n        length = len(digits := digits)\n        pow9 = [1] * (length + 1)\n        for i in range(1, length + 1):\n            pow9[i] = pow9[i-1] * 9\n        total = 0\n        for l in range(1, length):\n            total += pow9[l]\n        count = 0\n        for pos, d in enumerate(digits):\n            remaining = length - pos - 1\n            for c in range(1, d):\n                count += pow9[remaining]\n            if d == 0:\n                break\n            if pos == length - 1:\n                count += 1\n        return total + count\n", "tests_passed": 2, "score": 0.6875}
{"code": "import sys\n\nclass Solution:\n    def distinctNumbers(self, n: int) -> int:\n        digits = list(map(int, str(n)))\n        L = len(digits := digits)\n        from functools import lru_cache\n\n        @lru_cache(None)\n        def dfs(pos: int, tight: bool, started: bool) -> int:\n            if pos == L:\n                return 1 if started else 0\n            limit = digits[pos] if tight else 9\n            total = 0\n            for d in range(limit + 1):\n                ntight = tight and d == limit\n                nstarted = started or d != 0\n                if nstarted and d == 0:\n                    continue\n                total += dfs(pos + 1, ntight, nstarted)\n            return total\n\n        return dfs(0, True, False)", "tests_passed": 2, "score": 0.68359375}
{"code": "import sys\n\nclass Solution:\n    def countDistinct(self, n: int) -> int:\n        digits = list(map(int, str(n)))\n        dp = {(1, 0): 1}\n        for dmax in digits:\n            newdp = {}\n            for (tight, started), cnt in dp.items():\n                maxdigit = dmax if tight else 9\n                for d in range(maxdigit + 1):\n                    ntight = tight and d == maxdigit\n                    if started:\n                        if d == 0:\n                            continue\n                        nstarted = 1\n                    else:\n                        if d == 0:\n                            nstarted = 0\n                        else:\n                            nstarted = 1\n                    key = (ntight, nstarted)\n                    newdp[key] = newdp.get(key, 0) + cnt\n            dp = newdp\n        return sum(cnt for (tight, started), cnt in dp.items() if started)", "tests_passed": 2, "score": 0.6796875}
{"code": "import sys\n\nclass Solution:\n    def countNumbers(self, n: int) -> int:\n        digits = list(map(int, str(n)))\n        from functools import lru_cache\n        L = len(digits)\n        @lru_cache(None)\n        def dfs(pos, tight, started):\n            if pos == L:\n                return 1 if started else 0\n            limit = digits[pos] if tight else 9\n            total = 0\n            for d in range(0, limit + 1):\n                ntight = tight and d == limit\n                if started:\n                    if d == 0:\n                        continue\n                    total += dfs(pos + 1, ntight, True)\n                else:\n                    if d == 0:\n                        total += dfs(pos + 1, ntight, False)\n                    else:\n                        total += dfs(pos + 1, ntight, True)\n            return total\n        return dfs(0, True, False)", "tests_passed": 2, "score": 0.6796875}
{"code": "import sys\nfrom functools import lru_cache\n\nclass Solution:\n    def countDistinctIntegers(self, n: int) -> int:\n        digits = list(map(int, str(n)))\n        L = len(digits)\n\n        @lru_cache(None)\n        def dp(pos: int, tight: bool, started: bool) -> int:\n            if pos == L:\n                return 1 if started else 0\n            limit = digits[pos] if tight else 9\n            total = 0\n            for d in range(limit + 1):\n                ntight = tight and (d == limit)\n                nstarted = started or d != 0\n                if nstarted and d == 0:\n                    continue\n                total += dp(pos + 1, ntight, nstarted)\n            return total\n\n        return dp(0, True, False)", "tests_passed": 2, "score": 0.6796875}
{"code": "import sys\nclass Solution:\n    def countDistinctAfterRemovingZeros(self, n: int) -> int:\n        digits = list(map(int, str(n)))\n        length = len(digits := digits)\n        from functools import lru_cache\n        @lru_cache(None)\n        def dfs(pos, tight):\n            if pos == length:\n                return 1\n            limit = digits[pos] if tight else 9\n            total = 0\n            for d in range(1, limit + 1):\n                if d == 0:\n                    continue\n                ntight = tight and d == limit\n                total += dfs(pos + 1, ntight)\n            return total\n        return dfs(0, True)\n        # Note: this counts numbers from 0 to n with no zero digits including 0.\n        # We need to exclude 0 itself:\n        # If n >= 0, subtract 1.\n        # But since we start from pos=0 and allowed digits 1..9, 0 is never counted.\n        # So the count is correct as is.", "tests_passed": 1, "score": 0.72265625}
{"code": "import sys\n\nclass Solution:\n    def distinctIntegers(self, n: int) -> int:\n        digits = list(map(int, str(n)))\n        L = len(digits)\n        # count numbers with shorter length\n        count = 0\n        power = 1\n        for k in range(1, L):\n            power *= 9\n            count += power\n        # same length\n        for i, d in enumerate(digits):\n            if d == 0:\n                break\n            # digits less than d\n            if d > 1:\n                count += 9 ** (L - i - 1)\n            if i == L - 1:\n                count += 1\n        return count\n", "tests_passed": 1, "score": 0.72265625}
{"code": "import sys\nclass Solution:\n    def distinctNumbers(self, n: int) -> int:\n        s = str(n)\n        L = len(s)\n        dp = [[0, 0] for _ in range(L + 1)]\n        dp[0][1] = 1\n        for i in range(L):\n            cur = int(s[i])\n            for tight in (0, 1):\n                if dp[i][tight] == 0:\n                    continue\n                limit = cur if tight else 9\n                for d in range(1, limit + 1):\n                    if d == 0:\n                        continue\n                    ntight = tight and d == cur\n                    dp[i + 1][ntight] += dp[i][tight]\n        return dp[L][0] + dp[L][1]", "tests_passed": 1, "score": 0.703125}
{"code": "import sys\nfrom functools import lru_cache\n\nclass Solution:\n    def countDistinct(self, n: int) -> int:\n        digits = list(map(int, str(n)))\n        L = len(digits)\n        @lru_cache(None)\n        def dfs(pos, tight):\n            if pos == L:\n                return 1\n            limit = digits[pos] if tight else 9\n            total = 0\n            for d in range(1, limit + 1):\n                if d == 0:\n                    continue\n                total += dfs(pos + 1, tight and d == limit)\n            return total\n        return dfs(0, True) - 0\n        # Subtract zero because dfs counts empty string as 1? No, base returns 1 when pos==L, representing one valid number for each path. No zero is excluded by loop starting from 1. Thus no subtraction needed. Return dfs(0, True)", "tests_passed": 1, "score": 0.703125}
{"code": "import sys\nclass Solution:\n    def countNumbers(self, n: int) -> int:\n        digits = list(map(int, str(n)))\n        from functools import lru_cache\n        @lru_cache(maxsize=None)\n        def dfs(pos: int, tight: bool) -> int:\n            if pos == len(digits):\n                return 1\n            limit = digits[pos] if tight else 9\n            res = 0\n            for d in range(1, limit + 1):\n                if d == 0: \n                    continue\n                res += dfs(pos + 1, tight and d == limit)\n            return res\n        return dfs(0, True) - 1  # exclude 0 which is not in range\n    def distinctIntegers(self, n: int) -> int:\n        return self.countNumbers(n)", "tests_passed": 0, "score": 0.72265625}
{"code": "We should verify with brute.\n\nimport sys\n\nclass Solution:\n    def countDistinct(self, n: int) -> int:\n        n_str = str(n)\n        m = len(n_str)\n        pow9 = [1]\n        for _ in range(m):\n            pow9.append(pow9[-1] * 9)\n        res = 0\n        tight = True\n        for i, ch in enumerate(n_str):\n            cur_digit = int(ch)\n            if not tight:\n                res += 9 ** (m - i - 1)\n                continue\n            for d in range(1, 10):\n                if d < cur_digit:\n                    res += 9 ** (m - i - 1)\n                elif d == cur_digit:\n                    break\n                else:\n                    break\n            if cur_digit == 0:\n                tight = False\n                break\n        if tight:\n            res += 1\n        total = res\n        for l in range(1, m):\n            total += 9 ** l\n        return total\nif __name__ == \"__import sys\nfrom functools import lru_cache\n\nclass Solution:\n    def countDistinctNumbers(self, n: int) -> int:\n        digits = list(map(int, str(n)))\n        L = len(digits := digits)\n        @lru_cache(None)\n        def dfs(pos: int, tight: bool, started: bool) -> int:\n            if pos == L:\n                return 1 if started else 0\n            limit = digits[pos] if tight else 9\n            res = 0\n            for d in range(limit + 1):\n                next_started = started or d != 0\n                if started and d == 0:\n                    continue\n                next_tight = tight and d == limit\n                res += dfs(pos + 1, next_tight, next_started)\n            return res\n        return dfs(0, True, False)", "tests_passed": 0, "score": 0.69921875}
{"code": "import sys\n\nclass Solution:\n    def countNumbers(self, n: int) -> int:\n        s = str(n)\n        L = len(s)\n        dp = [[0, 0], [0, 0]]  # dp[tight][started]\n        dp[1][0] = 1\n        for ch in s:\n            lim_digit = int(ch)\n            new = [[0, 0], [0, 0]]\n            for tight in (0, 1):\n                for started in (import sys\nfrom functools import lru_cache\n\nclass Solution:\n    def countDistinct(self, n: int) -> int:\n        s = str(n)\n        length = len(s)\n        @lru_cache(None)\n        def dfs(pos: int, tight: int) -> int:\n            if pos == length:\n                return 1\n            limit = int(s[pos]) if tight else 9\n            res = 0\n            for d in range(1, limit + 1):\n                if d == 0:\n                    continue\n                res += dfs(pos + 1, tight and d == limit)\n            return res\n        # count numbers with same length\n        same_len = 0\n        for pos in range(length):\n            pass\n        same_len = dfs(0, True)\n        # subtract the empty number counted when no digits placed? but dfs counts 1 for exact n if all digits allowed\n        # however numbers cannot have digit 0, so dfs already respects that\n        # Now count shorter lengths\n        shorter = 0\n        for l in range(1, length):\n            shorter += 9 ** l\n        return same_len + shorter\nif __name__ == \"__main__\":\n    pass", "tests_passed": 0, "score": 0.69921875}
