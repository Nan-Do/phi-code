{"code": "import sys\nclass Solution:\n    def longestZeroXorEqualParity(self, nums):\n        xor = 0\n        diff = 0\n        earliest = {(0, 0): -1}\n        best = 0\n        for i, v in enumerate(nums):\n            xor ^= v\n            if v % 2 == 0:\n                diff += 1\n            else:\n                diff -= 1\n            key = (xor, diff)\n            if key in earliest:\n                best = max(best, i - earliest[key])\n            else:\n                earliest[key] = i\n        return best\n\nif __name__ == \"__main__\":\n    sys.setrecursionlimit(1 << 25)\n    s = Solution()\n    print(s.longestZeroXorEqualParity([3,1,3,2,0]))\n    print(s.longestZeroXorEqualParity([3,2,8,5,4,14,9,15]))\n    print(s.longestZeroXorEqualParity([0]))\n", "tests_passed": 3, "score": 0.796875}
{"code": "import sys\nclass Solution:\n    def longestZeroXorEvenOdd(self, nums):\n        n=len(nums)\n        xor=0\n        diff=0\n        earliest={}\n        earliest[(0,0)]=-1\n        best=0\n        for i,val in enumerate(nums):\n            xor^=val\n            if val%2==0:\n                diff+=1\n            else:\n                diff-=1\n            key=(xor,diff)\n            if key in earliest:\n                best=max(best,i-earliest[key])\n            else:\n                earliest[key]=i\n        return best\n\nif __name__==\"__main__\":\n    s=Solution()\n    print(s.longestZeroXorEvenOdd([3,1,3,2,0]))\n    print(s.longestZeroXorEvenOdd([3,2,8,5,4,14,9,15]))\n    print(s.longestZeroXorEvenOdd([0]))\n", "tests_passed": 3, "score": 0.796875}
{"code": "import sys\n\nclass Solution:\n    def longestZeroXorEqualParity(self, nums: list[int]) -> int:\n        first = {(0, 0): 0}\n        xor = 0\n        diff = 0\n        best = 0\n        for i, val in enumerate(nums, 1):\n            xor ^= val\n            diff += 1 if val % 2 == 0 else -1\n            key = (xor, diff)\n            if key in first:\n                best = max(best, i - first[key])\n            else:\n                first[key] = i\n        return best if best > 0 else 0", "tests_passed": 3, "score": 0.79296875}
{"code": "import sys\n\nclass Solution:\n    def longestEvenOddXOR(self, nums):\n        pref_xor = 0\n        pref_diff = 0\n        earliest = {(0, 0): 0}\n        max_len = 0\n        for i, val in enumerate(nums, 1):\n            pref_xor ^= val\n            pref_diff += 1 if val & 1 else -1\n            key = (pref_xor, pref_diff)\n            if key in earliest:\n                length = i - earliest[key]\n                if length > max_len:\n                    max_len = length\n            else:\n                earliest[key] = i\n        return max_len if max_len > 0 else 0\nif __name__ == \"__main__\":\n    sys.setrecursionlimit(1 << 25)\n    s = Solution()\n    print(s.longestEvenOddXOR([3,1,3,2,0]))\n    print(s.longestEvenOddXOR([3,2,8,5,4,14,9,15]))\n    print(s.longestEvenOddXOR([0]))\n", "tests_passed": 3, "score": 0.79296875}
{"code": "import sys\n\nclass Solution:\n    def longestZeroXorEqualParity(self, nums):\n        prefix_xor = 0\n        diff = 0  # even - odd\n        seen = {(0, 0): 0}\n        best = 0\n        for i, val in enumerate(nums, 1):\n            prefix_xor ^= val\n            if val % 2 == 0:\n                diff += 1\n            else:\n                diff -= 1\n            key = (prefix_xor, diff)\n            if key in seen:\n                best = max(best, i - seen[key])\n            else:\n                seen[key] = i\n        return best\n\nif __name__ == \"__main__\":\n    pass", "tests_passed": 3, "score": 0.79296875}
{"code": "import sys\nclass Solution:\n    def longestZeroXorEvenOdd(self, nums):\n        prefix = 0\n        d = 0\n        best = 0\n        first = {(0, 0): 0}\n        for i, val in enumerate(nums):\n            prefix ^= val\n            d += 1 if val % 2 == 0 else -1\n            key = (prefix, d)\n            idx = i + 1\n            if key in first:\n                length = idx - first[key]\n                if length > best:\n                    best = length\n            else:\n                first[key] = idx\n        return best if best > 0 else 0", "tests_passed": 3, "score": 0.7890625}
{"code": "import sys\nclass Solution:\n    def longestZeroXorEqualParity(self, nums):\n        n=len(nums)\n        prefix_xor=0\n        diff=0\n        earliest={ (0,0):0 }\n        best=0\n        for i in range(1,n+1):\n            v=nums[i-1]\n            prefix_xor ^= v\n            if v%2==0:\n                diff +=1\n            else:\n                diff -=1\n            key=(prefix_xor,diff)\n            if key in earliest:\n                best=max(best,i-earliest[key])\n            else:\n                earliest[key]=i\n        return best\n\nif __name__==\"__main__\":\n    sol=Solution()\n    print(sol.longestZeroXorEqualParity([3,1,3,2,0]))\n    print(sol.longestZeroXorEqualParity([3,2,8,5,4,14,9,15]))\n    print(sol.longestZeroXorEqualParity([0]))\n", "tests_passed": 3, "score": 0.7890625}
{"code": "import sys\nclass Solution:\n    def longestZeroXorEvenOdd(self, nums):\n        best = 0\n        xor_val = 0\n        diff = 0\n        seen = {(0, 0): 0}\n        for i, num in enumerate(nums, 1):\n            xor_val ^= num\n            diff += 1 if num % 2 == 0 else -1\n            key = (xor_val, diff)\n            if key in seen:\n                best = max(best, i - seen[key])\n            else:\n                seen[key] = i\n        return best\nif __name__ == \"__main__\":\n    print(Solution().longestZeroXorEvenOdd([3,1,3,2,0]))\n    print(Solution().longestZeroXorEvenOdd([3,2,8,5,4,14,9,15]))\n    print(Solution().longestZeroXorEvenOdd([0]))", "tests_passed": 3, "score": 0.78515625}
{"code": "import sys\nfrom collections import defaultdict\n\nclass Solution:\n    def longestXorZeroEvenOdd(self, nums):\n        pref = 0\n        diff = 0\n        earliest = {(0, 0): -1}\n        maxlen = 0\n        for i, val in enumerate(nums):\n            pref ^= val\n            diff += 1 if val % 2 == 0 else -1\n            key = (pref, diff)\n            if key in earliest:\n                length = i - earliest[key]\n                if length > maxlen:\n                    maxlen = length\n            else:\n                earliest[key] = i\n        return maxlen", "tests_passed": 3, "score": 0.78515625}
{"code": "import sys\n\nclass Solution:\n    def longestZeroXOREqualParity(self, nums: list[int]) -> int:\n        xor = 0\n        diff = 0  # even count minus odd count\n        first = {(0, 0): 0}\n        max_len = 0\n        for i, v in enumerate(nums, 1):\n            xor ^= v\n            diff += 1 if (v & 1) == 0 else -1\n            key = (xor, diff)\n            if key in first:\n                length = i - first[key]\n                if length > max_len:\n                    max_len = length\n            else:\n                first[key] = i\n        return max_len if max_len > 0 else 0", "tests_passed": 3, "score": 0.78515625}
{"code": "import sys\n\nclass Solution:\n    def longestZeroXorEvenOdd(self, nums):\n        px = 0\n        o = 0\n        earliest = {(0, 0): 0}\n        ans = 0\n        for i, val in enumerate(nums):\n            px ^= val\n            if val & 1:\n                o += 1\n            k = i + 1\n            d = 2 * o - k\n            key = (px, d)\n            if key in earliest:\n                length = k - earliest[key]\n                if length > ans:\n                    ans = length\n            else:\n                earliest[key] = k\n        return ans", "tests_passed": 3, "score": 0.78125}
{"code": "import sys\nclass Solution:\n    def longestZeroXOREvenOdd(self, nums):\n        pref_xor = 0\n        diff = 0\n        earliest = {(0, 0): -1}\n        max_len = 0\n        for i, v in enumerate(nums):\n            pref_xor ^= v\n            diff += 1 if v % 2 == 0 else -1\n            key = (pref_xor, diff)\n            if key in earliest:\n                max_len = max(max_len, i - earliest[key])\n            else:\n                earliest[key] = i\n        return max_len if max_len else 0", "tests_passed": 3, "score": 0.78125}
{"code": "import sys\nclass Solution:\n    def longestZeroXOREvenOdd(self, nums: list[int]) -> int:\n        n = len(nums)\n        prefix_xor = 0\n        even_count = 0\n        odd_count = 0\n        earliest = {(0, 0): -1}\n        max_len = 0\n        for i, v in enumerate(nums):\n            prefix_xor ^= v\n            if v % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n            diff = even_count - odd_count\n            key = (prefix_xor, diff)\n            if key in earliest:\n                l = i - earliest[key]\n                if l > max_len:\n                    max_len = l\n            else:\n                earliest[key] = i\n        return max_len\n", "tests_passed": 3, "score": 0.78125}
{"code": "import sys\n\nclass Solution:\n    def longestBalancedXorZeroSubarray(self, nums):\n        prefix_xor = 0\n        diff = 0\n        earliest = {(0, 0): -1}\n        res = 0\n        for idx, val in enumerate(nums):\n            prefix_xor ^= val\n            diff += 1 if val % 2 == 0 else -1\n            key = (prefix_xor, diff)\n            if key in earliest:\n                res = max(res, idx - earliest[key])\n            else:\n                earliest[key] = idx\n        return res\n\nif __name__ == \"__main__\":\n    sys.setrecursionlimit(1 << 20)", "tests_passed": 3, "score": 0.77734375}
{"code": "import sys\nclass Solution:\n    def longestZeroXorEqualParity(self, nums):\n        xor = 0\n        bal = 0\n        earliest = {(0, 0): 0}\n        maxlen = 0\n        for i, val in enumerate(nums, 1):\n            xor ^= val\n            bal += 1 if val % 2 == 0 else -1\n            key = (xor, bal)\n            if key in earliest:\n                length = i - earliest[key]\n                if length > maxlen:\n                    maxlen = length\n            else:\n                earliest[key] = i\n        return maxlen if maxlen > 0 else 0\nif __name__ == \"__main__\":\n    sys.setrecursionlimit(10000000)", "tests_passed": 3, "score": 0.77734375}
{"code": "import sys\n\nclass Solution:\n    def longestEqualParityXorZero(self, nums):\n        n = len(nums)\n        prefix_xor = 0\n        diff = 0  # even - odd\n        earliest = {(0, 0): 0}\n        maxlen = 0\n        for i, val in enumerate(nums, 1):\n            prefix_xor ^= val\n            if val % 2 == 0:\n                diff += 1\n            else:\n                diff -= 1\n            key = (prefix_xor, diff)\n            if key in earliest:\n                length = i - earliest[key]\n                if length > maxlen:\n                    maxlen = length\n            else:\n                earliest[key] = i\n        return maxlen if maxlen > 0 else 0\nif __name__ == \"__main__\":\n    sys.setrecursionlimit(10**7)", "tests_passed": 3, "score": 0.7734375}
{"code": "import sys\nfrom typing import List\n\nclass Solution:\n    def longestEvenOddXorZero(self, nums: List[int]) -> int:\n        prefix_xor = 0\n        odd = 0\n        even = 0\n        seen = {(0, 0): 0}\n        max_len = 0\n        for i, val in enumerate(nums, 1):\n            prefix_xor ^= val\n            if val & 1:\n                odd += 1\n            else:\n                even += 1\n            key = (prefix_xor, odd - even)\n            if key in seen:\n                length = i - seen[key]\n                if length > max_len:\n                    max_len = length\n            else:\n                seen[key] = i\n        return max_len\n\nif __name__ == \"__main__\":\n    pass", "tests_passed": 3, "score": 0.7734375}
{"code": "import sys\nclass Solution:\n    def longestEqualEvenOddXorZero(self, nums):\n        prefix_xor = 0\n        diff = 0\n        earliest = {(0, 0): 0}\n        max_len = 0\n        for idx, val in enumerate(nums, 1):\n            prefix_xor ^= val\n            diff += 1 if val % 2 == 0 else -1\n            key = (prefix_xor, diff)\n            if key in earliest:\n                length = idx - earliest[key]\n                if length > max_len:\n                    max_len = length\n            else:\n                earliest[key] = idx\n        return max_len\nif __name__ == \"__main__\":\n    pass", "tests_passed": 3, "score": 0.7734375}
{"code": "import sys\n\nclass Solution:\n    def longestBalancedXORSubarray(self, nums):\n        pref = 0\n        diff = 0\n        earliest = {(0, 0): 0}\n        maxlen = 0\n        for i, v in enumerate(nums, 1):\n            pref ^= v\n            diff += 1 if v % 2 == 0 else -1\n            key = (pref, diff)\n            if key in earliest:\n                maxlen = max(maxlen, i - earliest[key])\n            else:\n                earliest[key] = i\n        return maxlen if maxlen > 0 else 0", "tests_passed": 3, "score": 0.76953125}
{"code": "import sys\nfrom collections import defaultdict\n\nclass Solution:\n    def longestBalancedXOR(self, nums):\n        n = len(nums)\n        prefXOR = 0\n        prefOdd = 0\n        best = 0\n        first = {}\n        first[(0, 0)] = 0\n        for i in range(n):\n            prefXOR ^= nums[i]\n            if nums[i] & 1:\n                prefOdd += 1\n            idx = i + 1\n            d = 2 * prefOdd - idx\n            key = (prefXOR, d)\n            if key in first:\n                length = idx - first[key]\n                if length > best:\n                    best = length\n            else:\n                first[key] = idx\n        return best if best > 0 else 0", "tests_passed": 3, "score": 0.76953125}
{"code": "import sys\n\nclass Solution:\n    def longestBalancedXOR(self, nums: list[int]) -> int:\n        px = 0\n        d = 0\n        first = {(0, 0): -1}\n        best = 0\n        for i, v in enumerate(nums):\n            px ^= v\n            d += 1 if (v & 1) == 0 else -1\n            key = (px, d)\n            if key in first:\n                best = max(best, i - first[key])\n            else:\n                first[key] = i\n        return best\n\nif __name__ == \"__main__\":\n    sys.setrecursionlimit(1 << 25)", "tests_passed": 3, "score": 0.76953125}
{"code": "import sys\n\nclass Solution:\n    def longestEqualParityXorZero(self, nums):\n        n = len(nums)\n        px = 0\n        pdiff = 0\n        first = {(0, 0): 0}\n        ans = 0\n        for i, v in enumerate(nums, 1):\n            px ^= v\n            pdiff += 1 if v % 2 == 0 else -1\n            key = (px, pdiff)\n            if key in first:\n                ans = max(ans, i - first[key])\n            else:\n                first[key] = i\n        return ans if ans else 0\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.longestEqualParityXorZero([3,1,3,2,0]))\n    print(sol.longestEqualParityXorZero([3,2,8,5,4,14,9,15]))\n    print(sol.longestEqualParityXorZero([0]))\n", "tests_passed": 3, "score": 0.765625}
{"code": "import sys\n\nclass Solution:\n    def longestSubarray(self, nums):\n        earliest = {(0, 0): 0}\n        xor_val = 0\n        odd = 0\n        even = 0\n        max_len = 0\n        for i, val in enumerate(nums):\n            xor_val ^= val\n            if val & 1:\n                odd += 1\n            else:\n                even += 1\n            diff = odd - even\n            key = (xor_val, diff)\n            pos = i + 1\n            if key in earliest:\n                max_len = max(max_len, pos - earliest[key])\n            else:\n                earliest[key] = pos\n        return max_len", "tests_passed": 3, "score": 0.76171875}
{"code": "import sys\n\nclass Solution:\n    def longestBalancedXorZero(self, nums):\n        n = len(nums)\n        earliest = {}\n        px = 0\n        diff = 0\n        ans = 0\n        earliest[(0, 0)] = 0\n        for i, val in enumerate(nums, 1):\n            px ^= val\n            if val % 2 == 0:\n                diff += 1\n            else:\n                diff -= 1\n            key = (px, diff)\n            if key in earliest:\n                ans = max(ans, i - earliest[key])\n            else:\n                earliest[key] = i\n        return ans", "tests_passed": 3, "score": 0.7578125}
{"code": "import sys\nfrom typing import List\n\nclass Solution:\n    def longestBalancedXorSubarray(self, nums: List[int]) -> int:\n        n = len(nums)\n        pref_even_odd = 0  # number of odds seen\n        px = 0\n        earliest = {(0, 0): 0}\n        max_len = 0\n        for i, val in enumerate(nums, 1):\n            px ^= val\n            pref_even_odd += val & 1\n            V = 2 * pref_even_odd - i\n            key = (px, V)\n            if key in earliest:\n                length = i - earliest[key]\n                if length > max_len:\n                    max_len = length\n            else:\n                earliest[key] = i\n        return max_len if max_len > 0 else 0\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.longestBalancedXorSubarray([3,1,3,2,0]))\n    print(sol.longestBalancedXorSubarray([3,2,8,5,4,14,9,15]))\n    print(sol.longestBalancedXorSubarray([0]))\n", "tests_passed": 3, "score": 0.7578125}
{"code": "import sys\n\nclass Solution:\n    def longestBalancedXorSubarray(self, nums):\n        xor = 0\n        diff = 0\n        best = 0\n        earliest = {(0, 0): -1}\n        for i, val in enumerate(nums):\n            xor ^= val\n            if val % 2 == 0:\n                diff += 1\n            else:\n                diff -= 1\n            key = (xor, diff)\n            if key in earliest:\n                length = i - earliest[key]\n                if length > best:\n                    best = length\n            else:\n                earliest[key] = i\n        return best\n", "tests_passed": 3, "score": 0.75390625}
{"code": "import sys\nclass Solution:\n    def longestSubarray(self, nums):\n        best = 0\n        pref_xor = 0\n        pref_diff = 0\n        first = {(0, 0): -1}\n        for i, val in enumerate(nums):\n            pref_xor ^= val\n            pref_diff += 1 if val % 2 == 0 else -1\n            key = (pref_xor, pref_diff)\n            if key in first:\n                length = i - first[key]\n                if length > best:\n                    best = length\n            else:\n                first[key] = i\n        return best if best > 0 else 0", "tests_passed": 3, "score": 0.75390625}
{"code": "import sys\n\nclass Solution:\n    def longestBalancedXorSubarray(self, nums):\n        prefix_xor = 0\n        diff = 0\n        best = 0\n        seen = {(0, 0): 0}\n        for i, val in enumerate(nums, 1):\n            prefix_xor ^= val\n            if val % 2 == 0:\n                diff += 1\n            else:\n                diff -= 1\n            key = (prefix_xor, diff)\n            if key in seen:\n                length = i - seen[key]\n                if length > best:\n                    best = length\n            else:\n                seen[key] = i\n        return best\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.longestBalancedXorSubarray([3,1,3,2,0]))\n    print(sol.longestBalancedXorSubarray([3,2,8,5,4,14,9,15]))\n    print(sol.longestBalancedXorSubarray([0]))\n", "tests_passed": 3, "score": 0.75}
{"code": "import sys\n\nclass Solution:\n    def longestBalancedXOR(self, nums):\n        n = len(nums)\n        pref = 0\n        odd = 0\n        first = {(0, 0): 0}\n        ans = 0\n        for i in range(1, n + 1):\n            pref ^= nums[i - 1]\n            odd += (nums[i - 1] & 1)\n            key = 2 * odd - i\n            tup = (pref, key)\n            if tup in first:\n                length = i - first[tup]\n                if length > ans:\n                    ans = length\n            else:\n                first[tup] = i\n        return ans\n", "tests_passed": 3, "score": 0.74609375}
{"code": "import sys\n\nclass Solution:\n    def longestBalancedXor(self, nums):\n        pref = 0\n        diff = 0\n        earliest = {(0, 0): 0}\n        best = 0\n        for i, val in enumerate(nums, 1):\n            pref ^= val\n            if val & 1:\n                diff -= 1\n            else:\n                diff += 1\n            key = (pref, diff)\n            if key in earliest:\n                length = i - earliest[key]\n                if length > best:\n                    best = length\n            else:\n                earliest[key] = i\n        return best\nif __name__ == \"__main__\":\n    pass", "tests_passed": 3, "score": 0.734375}
