{"code": "import sys\nclass Solution:\n    def numberOfEffectiveSubsequences(self, nums):\n        mod = 10**9+7\n        n = len(nums)\n        T = 0\n        for v in nums: T |= v\n        bits = []\n        for i in range(20):\n            if T>>i &1: bits.append(i)\n        m = len(bits)\n        if m==0: return 0\n        size = 1<<m\n        freq = [0]*size\n        for v in nums:\n            mask = 0\n            for idx,b in enumerate(bits):\n                if v>>b &1: mask |= 1<<idx\n            freq[mask] += 1\n        dp = freq[:]\n        for i in range(m):\n            for mask in range(size):\n                if mask>>i &1:\n                    dp[mask] += dp[mask ^ (1<<i)]\n        pow2 = [1]*(n+1)\n        for i in range(1,n+1): pow2[i] = pow2[i-1]*2%mod\n        ans = 0\n        full = size-1\n        for P in range(1,size):\n            comp = full ^ P\n            union_size = n - dp[comp]\n            term = pow2[n - union_size]\n            if bin(P).count('1')%2==1:\n                ans = (ans + term)%mod\n            else:\n                ans = (ans - term)%mod\n        return ans%mod", "tests_passed": 4, "score": 0.7890625}
{"code": "import sys\nimport math\n\nclass Solution:\n    def countEffectiveSubsequences(self, nums):\n        MOD = 10**9+7\n        n = len(nums)\n        OR_all = 0\n        for v in nums:\n            OR_all |= v\n        # collect bits present\n        bits = []\n        for b in range(20):\n            if OR_all>>b & 1:\n                bits.append(b)\n        m = len(bits)\n        if m==0:\n            return 0\n        fullmask = (1<<m)-1\n        freq = [0]*(1<<m)\n        for v in nums:\n            mask = 0\n            for i,b in enumerate(bits):\n                if v>>b & 1:\n                    mask |= 1<<i\n            freq[mask] += 1\n        h = freq[:]\n        for i in range(m):\n            bit = 1<<i\n            for mask in range(1<<m):\n                if mask & bit:\n                    h[mask] += h[mask ^ bit]\n        pow2 = [1]*(n+1)\n        for i in range(1,n+1):\n            pow2[i] = (pow2[i-1]*2)%MOD\n        ans = 0\n        for B in range(1,1<<m):\n            comp = (~B)&fullmask\n            cnt_not = h[comp]\n            need = n - cnt_not\n            val = pow2[n-need]\n            if bin(B).count('1')%2==1:\n                ans = (ans + val)%MOD\n            else:\n                ans = (ans - val)%MOD\n        return ans%MOD\n       ", "tests_passed": 4, "score": 0.78125}
{"code": "import sys\n\nclass Solution:\n    def numberOfEffectiveSubsequences(self, nums):\n        MOD = 10**9 + 7\n        N = len(nums)\n        max_bit = max(nums).bit_length()\n        masks = [0] * max_bit\n        for i, val in enumerate(nums):\n            v = val\n            b = 0\n            while v:\n                if v & 1:\n                    masks[b] |= 1 << i\n                v >>= 1\n                b += 1\n        B = max_bit\n        pow2 = [1] * (N + 1)\n        for i in range(1, N + 1):\n            pow2[i] = (pow2[i - 1] << 1) % MOD\n        total_subsets = 1 << B\n        union_mask = [0] * total_subsets\n        size = [0] * total_subsets\n        for s in range(1, total_subsets):\n            lsb = s & -s\n            prev = s ^ lsb\n            bit_idx = (lsb.bit_length() - 1)\n            union_mask[s] = union_mask[prev] | masks[bit_idx]\n            size[s] = union_mask[s].bit_count()\n        ans = 0\n        for s in range(1, total_subsets):\n            bits = size[s]\n            exp = N - bits\n            val = pow2[exp]\n            if (s.bit_count() & 1):\n                ans = (ans + val) % MOD\n            else:\n                ans = (ans - val) % MOD\n        return ans % MOD\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.numberOfEffectiveSubsequences([1,2,3]))\n    print(sol.numberOfEffectiveSubsequences([7,4,6]))\n    print(sol.numberOfEffectiveSubsequences([8,8]))\n    print(sol.numberOfEffectiveSubsequences([2,2,1]))\n", "tests_passed": 3, "score": 0.78515625}
{"code": "import sys\n\nMOD = 10 ** 9 + 7\n\nclass Solution:\n    def numberOfEffectiveSubsequences(self, nums):\n        n = len(nums)\n        max_bit = max(nums).bit_length()\n        B = max_bit\n        M = 1 << B\n        freq = [0] * M\n        for x in nums:\n            freq[x] += 1\n        # subset DP to get sum over subsets\n        h = freq[:]\n        for i in range(B):\n            bit = 1 << i\n            for mask in range(M):\n                if mask & bit:\n                    h[mask] += h[mask ^ bit]\n        # precompute powers of 2\n        pow2 = [1] * (n + 1)\n        for i in range(1, n + 1):\n            pow2[i] = (pow2[i - 1] << 1) % MOD\n        res = 0\n        full_mask = M - 1\n        for T in range(1, M):\n            comp = full_mask ^ T\n            required_count = n - h[comp]\n            term = pow2[n - required_count]\n            if bin(T).count(\"1\") & 1:\n                res = (res + term) % MOD\n            else:\n                res = (res - term) % MOD\n        return res % MOD\n", "tests_passed": 3, "score": 0.77734375}
{"code": "import sys\n\nclass Solution:\n    def numberOfEffectiveSubsequences(self, nums):\n        MOD = 10**9 + 7\n        n = len(nums)\n        max_val = max(nums)\n        B = max_val.bit_length()\n        size = 1 << B\n        freq = [0] * size\n        for x in nums:\n            freq[x] += 1\n        arr = freq[:]\n        for i in range(B):\n            step = 1 << i\n            for mask in range(size):\n                if mask & step:\n                    arr[mask] += arr[mask ^ step]\n        pow2 = [1] * (n + 1)\n        for i in range(1, n + 1):\n            pow2[i] = (pow2[i-1] * 2) % MOD\n        full_mask = size - 1\n        ans = 0\n        for mask in range(1, size):\n            comp = full_mask ^ mask\n            cnt_zero = arr[comp]\n            term = pow2[cnt_zero]\n            if (mask.bit_count() & 1):\n                ans += term\n            else:\n                ans -= term\n        ans %= MOD\n        return ans", "tests_passed": 3, "score": 0.7734375}
{"code": "import sys\nfrom collections import defaultdict\n\nclass Solution:\n    def countEffectiveSubsequences(self, nums):\n        MOD = 10**9 + 7\n        N = len(nums)\n        if N == 0:\n            return 0\n        # Determine number of bits needed\n        max_val = max(nums)\n        B = max_val.bit_length()\n        size = 1 << B\n        freq = [0] * size\n        for x in nums:\n            freq[x] += 1\n        h = freq[:]  # copy\n        # SOS DP to compute sums over subsets\n        for i in range(B):\n            bit = 1 << i\n            for mask in range(size):\n                if mask & bit:\n                    h[mask] += h[mask ^ bit]\n        # precompute powers of two\n        pow2 = [1] * (N + 1)\n        for i in range(1, N + 1):\n            pow2[i] = (pow2[i - 1] * 2) % MOD\n        full_mask = size - 1\n        ans = 0\n        for S in range(1, size):\n            comp = full_mask ^ S\n            val = pow2[h[comp]]\n            if S.bit_count() & 1:\n                ans += val\n            else:\n                ans -= val\n            ans %= MOD\n        return ans % MOD\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.countEffectiveSubsequences([1,2,3]))\n    print(sol.countEffectiveSubsequences([7,4,6]))\n    print(sol.countEffectiveSubsequences([8,8]))\n    print(sol.countEffectiveSubsequences([2,2,1]))\n", "tests_passed": 3, "score": 0.765625}
{"code": "import sys\nclass Solution:\n    def countEffectiveSubsequences(self, nums):\n        mod = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        max_val = max(nums)\n        bitlen = max_val.bit_length()\n        fullmask = (1 << bitlen) - 1\n        size = 1 << bitlen\n        freq = [0] * size\n        for x in nums:\n            freq[x] += 1\n        dp = freq[:]\n        for i in range(bitlen):\n            step = 1 << i\n            for mask in range(size):\n                if mask & step:\n                    dp[mask] += dp[mask ^ step]\n        pow2 = [1] * (n + 1)\n        for i in range(1, n + 1):\n            pow2[i] = (pow2[i - 1] * 2) % mod\n        ans = 0\n        for T in range(1, size):\n            complement = (~T) & fullmask\n            unionsize = n - dp[complement]\n            term = pow2[n - unionsize]\n            if bin(T).count('1') & 1:\n                ans += term\n            else:\n                ans -= term\n        return ans % mod\nif __name__ == \"__main__\":\n    print(Solution().countEffectiveSubsequences([1,2,3]))\n    print(Solution().countEffectiveSubsequences([7,4,6]))\n    print(Solution().countEffectiveSubsequences([8,8]))\n    print(Solution().countEffectiveSubsequences([2,2,1]))\n", "tests_passed": 3, "score": 0.765625}
{"code": "import sys\n\nclass Solution:\n    def countEffectiveSubsequences(self, nums):\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        max_val = max(nums)\n        B = max_val.bit_length()\n        size = 1 << B\n        cnt = [0] * size\n        for x in nums:\n            cnt[x] += 1\n        f = cnt[:]\n        for i in range(B):\n            bit = 1 << i\n            for mask in range(size):\n                if mask & bit:\n                    f[mask] += f[mask ^ bit]\n        pow2 = [1] * (n + 1)\n        for i in range(1, n + 1):\n            pow2[i] = (pow2[i - 1] << 1) % MOD\n        full_mask = size - 1\n        ans = 0\n        for T in range(1, size):\n            comp = full_mask ^ T\n            val = f[comp]\n            pop = T.bit_count()\n            if pop & 1:\n                ans += pow2[val]\n            else:\n                ans -= pow2[val]\n        ans %= MOD\n        return ans\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.countEffectiveSubsequences([1,2,3]))\n    print(sol.countEffectiveSubsequences([7,4,6]))\n    print(sol.countEffectiveSubsequences([8,8]))\n    print(sol.countEffectiveSubsequences([2,2,1]))\n", "tests_passed": 3, "score": 0.76171875}
{"code": "import sys\nclass Solution:\n    def countEffectiveSubsequences(self, nums):\n        mod = 10**9+7\n        n = len(nums)\n        max_bit = max(nums).bit_length()\n        if max_bit == 0:\n            return 0\n        fullmask = (1<<max_bit)-1\n        freq = [0]*(1<<max_bit)\n        for x in nums:\n            freq[x] += 1\n        dp = freq[:]\n        for i in range(max_bit):\n            bit = 1<<i\n            for mask in range(dp.__len__()):\n                if mask & bit:\n                    dp[mask] = (dp[mask] + dp[mask ^ bit])%mod\n        pow2 = [1]*(n+1)\n        for i in range(1,n+1):\n            pow2[i] = (pow2[i-1]*2)%mod\n        ans = 0\n        for mask in range(1,1<<max_bit):\n            cnt_zero = dp[fullmask ^ mask]\n            bits = mask.bit_count()\n            contrib = pow2[cnt_zero]\n            if bits%2==1:\n                ans = (ans + contrib)%mod\n            else:\n                ans = (ans - contrib)%mod\n        return ans%mod\nif __name__==\"__main__\":\n    s=Solution()\n    print(s.countEffectiveSubsequences([1,2,3]))\n    print(s.countEffectiveSubsequences([7,4,6]))\n    print(s.countEffectiveSubsequences([8,8]))\n    print(s.countEffectiveSubsequences([2,2,1]))\n", "tests_passed": 3, "score": 0.76171875}
{"code": "import sys\n\nclass Solution:\n    def countEffectiveSubsequences(self, nums):\n        MOD = 10**9 + 7\n        n = len(nums)\n        max_val = max(nums)\n        max_bit = max_val.bit_length()\n        max_mask = (1 << max_bit) - 1\n        size = max_mask + 1\n        freq = [0] * size\n        for v in nums:\n            freq[v] += 1\n        dp = freq[:]  # will hold sum over subsets\n        for i in range(max_bit):\n            step = 1 << i\n            for mask in range(size):\n                if mask & step:\n                    dp[mask] += dp[mask ^ step]\n        result = 0\n        pow2_cache = pow(2, n, MOD)\n        for mask in range(1, size):\n            complement = max_mask ^ mask\n            disjoint = dp[complement]\n            union_size = n - disjoint\n            exp = n - union_size\n            val = pow(2, exp, MOD)\n            if bin(mask).count('1') & 1:\n                result = (result + val) % MOD\n            else:\n                result = (result - val) % MOD\n        return result % MOD\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.countEffectiveSubsequences([1,2,3]))\n    print(sol.countEffectiveSubsequences([7,4,6]))\n    print(sol.countEffectiveSubsequences([8,8]))\n    print(sol.countEffectiveSubsequences([2,2,1]))\n", "tests_passed": 3, "score": 0.7578125}
{"code": "import sys\n\nclass Solution:\n    def numberOfEffectiveSubsequences(self, nums):\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        max_val = max(nums)\n        max_bit = max_val.bit_length()\n        size = 1 << max_bit\n        freq = [0] * size\n        for v in nums:\n            freq[v] += 1\n        f = freq[:]  # copy\n        for i in range(max_bit):\n            step = 1 << i\n            for mask in range(size):\n                if mask & step:\n                    f[mask] += f[mask ^ step]\n        pow2 = [1] * (n + 1)\n        for i in range(1, n + 1):\n            pow2[i] = (pow2[i - 1] << 1) % MOD\n        ans = 0\n        for mask in range(1, size):\n            bits_set = mask.bit_count()\n            complement = (~mask) & (size - 1)\n            union_size = n - f[complement]\n            term = pow2[n - union_size]\n            if bits_set & 1:\n                ans += term\n            else:\n                ans -= term\n        ans %= MOD\n        return ans\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.numberOfEffectiveSubsequences([1,2,3]))\n    print(sol.numberOfEffectiveSubsequences([7,4,6]))\n    print(sol.numberOfEffectiveSubsequences([8,8]))\n    print(sol.numberOfEffectiveSubsequences([2,2,1]))\n", "tests_passed": 3, "score": 0.75}
{"code": "import sys\nfrom collections import defaultdict\nclass Solution:\n    def countEffectiveSubsequences(self, nums):\n        MOD = 10**9 + 7\n        n = len(nums)\n        if n == 0:\n            return 0\n        # Determine bits that appear\n        max_val = max(nums)\n        bits = max_val.bit_length()\n        if bits == 0:\n            return 0\n        present_bits = 0\n        for v in nums:\n            present_bits |= v\n        relevant = []\n        bit_to_idx = {}\n        for b in range(bits):\n            if present_bits & (1 << b):\n                bit_to_idx[b] = len(relevant)\n        k = len(bit_to_idx)\n        if k == 0", "tests_passed": 0, "score": 0.80859375}
{"code": "import sys\nMOD = 10**9 + 7\n\nclass Solution:\n    def countEffectiveSubsequences(self, nums):\n        n = len(nums)\n        B = 20\n        N = 1 << B\n        freq = [0] * N\n        for x in nums:\n            mask = 0\n            for b in range(B):\n                if x >> b & 1:\n                    mask |= 1 << b\n            freq[mask] += 1\n        dp = freq[:]\n        for i in range(B):\n            bit = 1 << i\n            for mask in range(N):\n                if mask & bit:\n                    dp[mask] += dp[mask ^ bit]\n        full = N - 1\n        res = 0\n        for m in range(1, N):\n            zero = dp[full ^ m]\n            term = pow(2, zero, MOD)\n            if bin(m).count('1') & 1:\n                res += term\n            else:\n                res -= term\n        return res % MOD", "tests_passed": 0, "score": 0.7890625}
{"code": "import sys\nfrom math import log2, floor\n\nclass Solution:\n    def countEffectiveSubsequences(self, nums):\n        MOD = 10**9 + 7\n        n = len(nums)\n        MAX_BITS = 20\n        FULL = (1 << MAX_BITS) - 1\n        size = 1 << MAX_BITS\n        freq = [0] * size\n        for x in nums:\n            mask = 0\n            while x:\n                lsb = x & -x\n                bit = (lsb.bit_length() - 1)\n                mask |= 1 << bit\n                x ^= lsb\n            freq[mask] += 1\n        g = freq[:]\n        for i in range(MAX_BITS):\n            bit = 1 << i\n            for mask in range(size):\n                if mask & bit:\n                    g[mask] += g[mask ^ bit]\n        pow2 = [1] * (n + 1)\n        for i in range(1, n + 1):\n            pow2[i] = (pow2[i-1] << 1) % MOD\n        ans = 0\n        for T in range(1, size):\n            comp = FULL ^ T\n            count_not = g[comp]\n            term = pow2[count_not]\n            if (T.bit_count() & 1):\n                ans = (ans + term) % MOD\n            else:\n                ans = (ans - term) % MOD\n        return ans % MOD\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.countEffectiveSubsequences([1,2,3]))\n    print(sol.countEffectiveSubsequences([7,4,6]))\n    print(sol.countEffectiveSubsequences([8,8]))\n    print(sol.countEffectiveSubsequences([2,2,1]))\n", "tests_passed": 0, "score": 0.78125}
{"code": "import sys\nimport math\nfrom collections import defaultdict\n\nclass Solution:\n    def countEffectiveSubsequences(self, nums):\n        MOD = 10**9 + 7\n        max_val = max(nums) if nums else 0\n        bits = []\n        for b in range(20):\n            if max_val >> b & 1:\n                bits.append(b)\n        m = len(bits)\n        if m == 0:\n            return 0\n        idx = {b:i for i,b in enumerate(bits)}\n        n = len(nums)\n        size = 1 << m\n        freq = [0] * size\n        for v in nums:\n            mask = 0\n            for b in bits:\n                if v >> b & 1:\n                    mask |= 1 << idx[b]\n            freq[mask] += 1\n        g = freq[:]\n        for i in range(m):\n            bit = 1 << i\n            for mask in range(size):\n                if mask & bit:\n                    g[mask] += g[mask ^ bit]\n        pow2 = [1] * (n+1)\n        for i in range(1, n+1):\n            pow2[i] = (pow2[i-1] * 2) % MOD\n        fullMask = size - 1\n        ans = 0\n        for T in range(1, size):\n            k = n - g[(~T) & fullMask]\n            term = pow2[k]\n            if (T & -T) == T:  # single bit? popcount odd via parity\n                pass\n            if bin(T).count(\"1\") & 1:\n                ans += term\n            else:\n                ans -= term\n            ans %= MOD\n        return ans % MOD", "tests_passed": 0, "score": 0.78125}
{"code": "import sys\n\nclass Solution:\n    def countEffectiveSubsequences(self, nums):\n        MOD = 10**9+7\n        maxbit = 20  # since nums[i] <= 1e6 < 2^20\n        fullmask = (1<<maxbit)-1\n        n = len(nums)\n        f = [0]*(1<<maxbit)\n        for v in nums:\n            f[v] += 1\n        # subset count\n        subcnt = f[:]\n        for i in range(maxbit):\n            bit = 1<<i\n            for mask in range(1<<maxbit):\n                if mask & bit:\n                    subcnt[mask] += subcnt[mask ^ bit]\n        # precompute powers of two\n        pow2 = [1]*(n+1)\n        for i in range(1,n+1):\n            pow2[i] = (pow2[i-1]*2)%MOD\n        ans = 0\n        for mask in range(1,1<<maxbit):\n            # size_union = n - subcnt[~mask & fullmask]\n            union_size = n - subcnt[ (~mask)&fullmask ]\n            val = pow2[n - union_size]\n            if bin(mask).count(\"1\")%2==1:\n                ans = (ans + val)%MOD\n            else:\n                ans = (ans - val)%MOD\n        return ans%MOD\n\n# For compatibility with LeetCode style\nSolution.countEffectiveSubsequences = Solution.countEffectiveSubsequences\nif __name__==\"__main__\":\n    s=Solution()\n    print(s.countEffectiveSubsequences([1,2,3]))\n    print(s.countEffectiveSubsequences([7,4,6]))\n    print(s.countEffectiveSubsequences([8,8]))\n    print(s.countEffectiveSubsequences([2,2,1]))", "tests_passed": 0, "score": 0.77734375}
{"code": "import sys\n\nMOD = 10**9 + 7\n\nclass Solution:\n    def numberOfEffectiveSubsequences(self, nums):\n        n = len(nums)\n        full_mask = (1 << 20) - 1\n        freq = [0] * (1 << 20)\n        T = 0\n        for x in nums:\n            freq[x] += 1\n            T |= x\n        h = freq[:]\n        for i in range(20):\n            bit = 1 << i\n            for mask in range(1 << 20):\n                if mask & bit:\n                    h[mask] += h[mask ^ bit]\n        pow2 = [1] * (n + 1)\n        for i in range(1, n + 1):\n            pow2[i] = (pow2[i - 1] * 2) % MOD\n        bits = [i for i in range(20) if (T >> i) & 1]\n        B = len(bits)\n        ans = 0\n        for mask in range(1, 1 << B):\n            bits_count = 0\n            submask = 0\n            for idx, b in enumerate(bits):\n                if mask >> idx & 1:\n                    bits_count += 1\n                    submask |= 1 << b\n            complement = full_mask ^ submask\n            exp = h[complement]\n            val = pow2[exp]\n            if bits_count % 2 == 1:\n                ans = (ans + val) % MOD\n            else:\n                ans = (ans - val) % MOD\n        return ans % MOD", "tests_passed": 0, "score": 0.77734375}
{"code": "import sys\nclass Solution:\n    def numberOfEffectiveSubsequences(self, nums):\n        MOD = 10**9 + 7\n        n = len(nums)\n        B = 20\n        fullMask = (1 << B) - 1\n        freq = [0] * (1 << B)\n        for v in nums:\n            freq[v] += 1\n        dp = freq[:]\n        for i in range(B):\n            bit = 1 << i\n            for mask in range(fullMask + 1):\n                if mask & bit:\n                    dp[mask] += dp[mask ^ bit]\n        pow2 = [1] * (n + 1)\n        for i in range(1, n + 1):\n            pow2[i] = (pow2[i - 1] * 2) % MOD\n        ans = 0\n        for T in range(1, fullMask + 1):\n            comp = fullMask ^ T\n            mT = n - dp[comp]\n            term = pow2[n - mT]\n            if (T.bit_count() & 1):\n                ans = (ans + term) % MOD\n            else:\n                ans = (ans - term) % MOD\n        return ans % MOD", "tests_passed": 0, "score": 0.77734375}
{"code": "import sys\n\nclass Solution:\n    def countEffectiveSubsequences(self, nums):\n        MOD = 10**9 + 7\n        max_bit = 20\n        size = 1 << max_bit\n        freq = [0] * size\n        for v in nums:\n            mask = 0\n            for b in range(max_bit):\n                if v >> b & 1:\n                    mask |= 1 << b\n            freq[mask] += 1\n        g = freq[:]\n        for i in range(max_bit):\n            bit = 1 << i\n            for mask in range(size):\n                if mask & bit:\n                    g[mask] = (g[mask] + g[mask ^ bit]) % MOD\n        n = len(nums)\n        pow2 = [1] * (n + 1)\n        for i in range(1, n + 1):\n            pow2[i] = (pow2[i - 1] * 2) % MOD\n        maskAll = size - 1\n        res = 0\n        for T in range(1, size):\n            bits = T.bit_count()\n            notT = (~T) & maskAll\n            exp = g[notT]\n            val = pow2[exp]\n            if bits & 1:\n                res = (res + val) % MOD\n            else:\n                res = (res - val) % MOD\n        return res % MOD\n\nif __name__ == \"__main__\":\n    print(Solution().countEffectiveSubsequences([1,2,3]))\n    print(Solution().countEffectiveSubsequences([7,4,6]))\n    print(Solution().countEffectiveSubsequences([8,8]))\n    print(Solution().countEffectiveSubsequences([2,2,1]))\n", "tests_passed": 0, "score": 0.7734375}
{"code": "import sys\nclass Solution:\n    def numberOfEffectiveSubsequences(self, nums):\n        MOD = 10**9 + 7\n        k = 20\n        full = (1 << k) - 1\n        size = 1 << k\n        f = [0] * size\n        for v in nums:\n            f[v] += 1\n        h = f[:]  # SOS DP\n        for i in range(k):\n            bit = 1 << i\n            for mask in range(size):\n                if mask & bit:\n                    h[mask] += h[mask ^ bit]\n        n = len(nums)\n        pow2 = [1] * (n + 1)\n        for i in range(1, n + 1):\n            pow2[i] = (pow2[i - 1] << 1) % MOD\n        ans = 0\n        for mask in range(1, size):\n            pop = mask.bit_count()\n            complement = (~mask) & full\n            exp = h[complement]  # number of elements with no intersection\n            term = pow2[exp]\n            if pop & 1:\n                ans += term\n            else:\n                ans -= term\n        return ans % MOD", "tests_passed": 0, "score": 0.7734375}
{"code": "import sys\n\nclass Solution:\n    def countEffectiveSubsequences(self, nums):\n        MOD = 10**9 + 7\n        n = len(nums)\n        k = 20  # since nums[i] <= 10^6 < 2^20\n        size = 1 << k\n        freq = [0] * size\n        for num in nums:\n            freq[num] += 1\n        g = freq[:]  # SOS DP\n        for i in range(k):\n            bit = 1 << i\n            for mask in range(size):\n                if mask & bit:\n                    g[mask] += g[mask ^ bit]\n        pow2 = [1] * (n + 1)\n        for i in range(1, n + 1):\n            pow2[i] = (pow2[i - 1] << 1) % MOD\n        total = 0\n        full_mask = size - 1\n        for Bmask in range(1, size):\n            comp = full_mask ^ Bmask\n            union_size = n - g[comp]\n            term = pow2[n - union_size]  # which equals pow2[g[comp]]\n            if bin(Bmask).count('1') & 1:\n                total = (total + term) % MOD\n            else:\n                total = (total - term) % MOD\n        return total % MOD\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.countEffectiveSubsequences([1,2,3]))\n    print(sol.countEffectiveSubsequences([7,4,6]))\n    print(sol.countEffectiveSubsequences([8,8]))\n    print(sol.countEffectiveSubsequences([2,2,1]))", "tests_passed": 0, "score": 0.76953125}
{"code": "import sys\n\nMOD = 10**9+7\nMAX_BITS = 20\nFULLMASK = (1<<MAX_BITS)-1\n\nclass Solution:\n    def countEffectiveSubsequences(self, nums):\n        n = len(nums)\n        size = 1<<MAX_BITS\n        cnt = [0]*size\n        for x in nums:\n            cnt[x] += 1\n        f = cnt[:]\n        for i in range(MAX_BITS):\n            bit = 1<<i\n            for mask in range(size):\n                if mask & bit:\n                    f[mask] += f[mask ^ bit]\n        bad = 0\n        pow2 = [1]*(n+1)\n        for i in range(1,n+1):\n            pow2[i] = pow2[i-1]*2%MOD\n        for B in range(1,size):\n            comp = (~B)&FULLMASK\n            R = f[comp]\n            term = pow2[R]\n            if (B.bit_count() & 1):\n                bad = (bad + term)%MOD\n            else:\n                bad = (bad - term)%MOD\n        total = pow2[n]\n        ans = (total - bad)%MOD\n        return ans\n\nif __name__=='__main__':\n    sol=Solution()\n    print(sol.countEffectiveSubsequences([1,2,3]))\n    print(sol.countEffectiveSubsequences([7,4,6]))\n    print(sol.countEffectiveSubsequences([8,8]))\n    print(sol.countEffectiveSubsequences([2,2,1]))", "tests_passed": 0, "score": 0.76953125}
{"code": "import sys\nMOD=10**9+7\nclass Solution:\n    def countEffectiveSubsequences(self, nums):\n        n=len(nums)\n        B=20\n        size=1<<B\n        freq=[0]*size\n        for x in nums:\n            freq[x]+=1\n        # SOS DP for counts of submasks\n        cnt=freq[:]\n        for i in range(B):\n            for m in range(size):\n                if m & (1<<i):\n                    cnt[m]+=cnt[m^(1<<i)]\n        pow2=[1]*(n+1)\n        for i in range(1,n+1):\n            pow2[i]=pow2[i-1]*2%MOD\n        total_nonempty=(pow2[n]-1)%MOD\n        bad=0\n        for m in range(1,size):\n            bits=bin(m).count('1')\n            union_size=n-cnt[m]\n            term=pow2[union_size]\n            if bits%2==1:\n                bad=(bad+term)%MOD\n            else:\n                bad=(bad-term)%MOD\n        bad=(bad+MOD)%MOD\n        bad=(bad-1)%MOD  # exclude E=all indices\n        ans=(total_nonempty-bad)%MOD\n        return ans\nif __name__=='__main__':\n    print(Solution().countEffectiveSubsequences([1,2,3]))\n    print(Solution().countEffectiveSubsequences([7,4,6]))\n    print(Solution().countEffectiveSubsequences([8,8]))\n    print(Solution().countEffectiveSubsequences([2,2,1]))\n", "tests_passed": 0, "score": 0.765625}
{"code": "import sys\nMOD = 10**9+7\n\nclass Solution:\n    def numberOfEffectiveSubsequences(self, nums):\n        n = len(nums)\n        bits = 20\n        size = 1 << bits\n        freq = [0] * size\n        for v in nums:\n            freq[v] += 1\n        f = freq[:]\n        for i in range(bits):\n            bit = 1 << i\n            for mask in range(size):\n                if mask & bit:\n                    f[mask] += f[mask ^ bit]\n        pow2 = [1] * (n + 1)\n        for i in range(1, n + 1):\n            pow2[i] = (pow2[i-1] << 1) % MOD\n        full = size - 1\n        res = 0\n        for K in range(1, size):\n            pc = K.bit_count()\n            sign = 1 if pc & 1 else -1\n            remaining = f[full ^ K]\n            res = (res + sign * pow2[remaining]) % MOD\n        return res % MOD\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.numberOfEffectiveSubsequences([1,2,3]))\n    print(sol.numberOfEffectiveSubsequences([7,4,6]))\n    print(sol.numberOfEffectiveSubsequences([8,8]))\n    print(sol.numberOfEffectiveSubsequences([2,2,1]))", "tests_passed": 0, "score": 0.76171875}
{"code": "import sys\nMOD = 10**9+7\n\nclass Solution:\n    def countEffectiveSubsequences(self, nums):\n        n = len(nums)\n        # Determine global OR and bits present\n        G = 0\n        for x in nums:\n            G |= x\n        if G == 0:\n            return 0\n        bits = []\n        bit_to_idx = {}\n        for b in range(20):\n            if (G>>b)&1:\n                bit_to_idx[b] = len(bits)\n                bits.append(b)\n        m = len(bits)\n        full_mask = (1<<m)-1\n        freq = [0]*(1<<m)\n        for x in nums:\n            mask = 0\n            for b in bits:\n                if (x>>b)&1:\n                    mask |= 1<<bit_to_idx[b]\n            freq[mask] += 1\n        # compute f[mask] = sum_{submask \u2286 mask} freq[submask]\n        f = freq[:]\n        for i in range(m):\n            for mask in range(1<<m):\n                if mask & (1<<i):\n                    f[mask] += f[mask ^ (1<<i)]\n        pow2 = [1]*(n+1)\n        for i in range(1,n+1):\n            pow2[i] = (pow2[i-1]*2)%MOD\n        ans = 0\n        for S in range(1,1<<m):\n            sign = 1 if bin(S).count(\"1\")%2==1 else -1\n            noS_mask = full_mask ^ S\n            cnt = f[noS_mask]\n            term = pow2[cnt]\n            if sign==1:\n                ans += term\n            else:\n                ans -= term\n            ans %= MOD\n        return ans%MOD\nif __name__ == \"__main__\":\n    sol=Solution()\n    print(sol.countEffectiveSubsequences([1,2,3import sys\nMOD = 10**9 + 7\nclass Solution:\n    def countEffectiveSubsequences(self, nums):\n        n = len(nums)\n        max_bit = 20\n        size = 1 << max_bit\n        f = [0] * size\n        for x in nums:\n            f[x] += 1\n        g = f[:]\n        for i in range(max_bit):\n            bit = 1 << i\n            for mask in range(size):\n                if mask & bit:\n                    g[mask] = (g[mask] + g[mask ^ bit]) % MOD\n        pow2 = [1] * (n + 1)\n        for i in range(1, n + 1):\n            pow2[i] = (pow2[i-1] * 2) % MOD\n        allbits = size - 1\n        res = 0\n        for B in range(1, size):\n            k = g[allbits ^ B]\n            val = pow2[k]\n            if bin(B).count('1') % 2 == 1:\n                res = (res + val) % MOD\n            else:\n                res = (res - val) % MOD\n        return res % MOD\nif __name__ == \"__main__\":\n    print(Solution().countEffectiveSubsequences([1,2,3]))\n    print(Solution().countEffectiveSubsequences([7,4,6]))\n    print(Solution().countEffectiveSubsequences([8,8]))\n    print(Solution().countEffectiveSubsequences([2,2,1]))", "tests_passed": 0, "score": 0.76171875}
{"code": "import sys\nfrom collections import defaultdict\n\nclass Solution:\n    def countEffectiveSubsequences(self, nums):\n        mod = 10**9+7\n        k = 20\n        full = (1<<k)-1\n        n = len(nums)\n        freq = [0]*(1<<k)\n        for x in nums:\n            freq[x] += 1\n        g = freq[:]\n        for i in range(k):\n            step = 1<<i\n            for mask in range(0, 1<<k, step*2):\n                for j in range(mask, mask+step):\n                    g[j] += g[j+step]\n        total = pow(2, n, mod)\n        ans = 0\n        for mask in range(1, 1<<k):\n            cnt = n - g[full ^ mask]\n            term = pow(2, cnt, mod)\n            if bin(mask).count('1')%2==1:\n                ans += term\n            else:\n                ans -= term\n            ans %= mod\n        return ans%mod\nif __name__==\"__main__\":\n    print(Solution().countEffectiveSubsequences([1,2,3]))\n    print(Solution().countEffectiveSubsequences([7,4,6]))\n    print(Solution().countEffectiveSubsequences([8,8]))\n    print(Solution().countEffectiveSubsequences([2,2,1]))\n", "tests_passed": 0, "score": 0.7578125}
