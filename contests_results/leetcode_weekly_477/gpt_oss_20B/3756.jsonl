{"code": "import bisect\n\nclass Solution:\n    def solveQueries(self, s, queries):\n        MOD = 10**9 + 7\n        m = len(s)\n        digits = [int(ch) for ch in s]\n        pref_val = [0]*m\n        cnt_pref = [0]*m\n        sum_pref = [0]*m\n        nz_indices = []\n        if digits[0] != 0:\n            pref_val[0] = digits[0]\n            cnt_pref[0] = 1\n            sum_pref[0] = digits[0]\n            nz_indices.append(0)\n        for i in range(1, m):\n            d = digits[i]\n            if d == 0:\n                pref_val[i] = pref_val[i-1]\n                cnt_pref[i] = cnt_pref[i-1]\n                sum_pref[i] = sum_pref[i-1]\n            else:\n                pref_val[i] = (pref_val[i-1]*10 + d) % MOD\n                cnt_pref[i] = cnt_pref[i-1] + 1\n                sum_pref[i] = sum_pref[i-1] + d\n                nz_indices.append(i)\n        total_nonzero = cnt_pref[-1]\n        pow10 = [1]*(total_nonzero+1)\n        for i in range(1, total_nonzero+1):\n            pow10[i] = (pow10[i-1]*10) % MOD\n        res = []\n        for l, r in queries:\n            left = bisect.bisect_left(nz_indices, l)\n            if left == len(nz_indices) or nz_indices[left] > r:\n                res.append(0)\n                continue\n            L = nz_indices[left]\n            right = bisect.bisect_right(nz_indices, r)-1\n            R = nz_indices[right]\n            cnt = cnt_pref[R] - (cnt_pref[L-1] if L>0 else 0)\n            sum_digits = sum_pref[R] - (sum_pref[L-1] if L>0 else 0)\n            val = (pref_val[R] - (pref_val[L-1]*pow10[cnt] if L>0 else 0)) % MOD\n            ans = (val * sum_digits) % MOD\n            res.append(ans)\n        return res", "tests_passed": 3, "score": 0.83984375}
{"code": "import sys\n\nMOD = 10**9 + 7\n\nclass Solution:\n    def getAnswers(self, s, queries):\n        n = len(s)\n        A = []\n        pos = [0]*(n+1)\n        for i,ch in enumerate(s,1):\n            if ch!='0':\n                A.append(int(ch))\n            pos[i] = len(A)\n        m = len(A)\n        pow10 = [1]*(m+1)\n        for i in range(1,m+1):\n            pow10[i] = (pow10[i-1]*10)%MOD\n        prefVal = [0]*m\n        if m>0:\n            prefVal[0] = A[0]%MOD\n            for i in range(1,m):\n                prefVal[i] = (prefVal[i-1]*10 + A[i])%MOD\n        prefSum = [0]*m\n        if m>0:\n            prefSum[0] = A[0]\n            for i in range(1,m):\n                prefSum[i] = prefSum[i-1] + A[i]\n        ans = []\n        for l,r in queries:\n            left = pos[l]\n            right = pos[r+1]\n            if left==right:\n                ans.append(0)\n                continue\n            len_seg = right-left\n            sumDigits = prefSum[right-1] - (prefSum[left-1] if left>0 else 0)\n            val = prefVal[right-1]\n            if left>0:\n                val = (val - prefVal[left-1]*pow10[len_seg])%MOD\n            ans.append(val*sumDigits%MOD)\n        return ans", "tests_passed": 3, "score": 0.8359375}
{"code": "import sys\nfrom typing import List\n\nMOD = 10 ** 9 + 7\n\nclass Solution:\n    def calculate(self, s: str, queries: List[List[int]]) -> List[int]:\n        n = len(s)\n        pow10 = [1] * (n + 1)\n        for i in range(1, n + 1):\n            pow10[i] = (pow10[i - 1] * 10) % MOD\n        prefixVal = [0] * n\n        lenNonZero = [0] * n\n        sumNonZero = [0] * n\n        for i, ch in enumerate(s):\n            d = ord(ch) - 48\n            if d == 0:\n                if i:\n                    prefixVal[i] = prefixVal[i - 1]\n                    lenNonZero[i] = lenNonZero[i - 1]\n                    sumNonZero[i] = sumNonZero[i - 1]\n                else:\n                    prefixVal[i] = 0\n                    lenNonZero[i] = 0\n                    sumNonZero[i] = 0\n            else:\n                if i:\n                    prefixVal[i] = (prefixVal[i - 1] * 10 + d) % MOD\n                    lenNonZero[i] = lenNonZero[i - 1] + 1\n                    sumNonZero[i] = sumNonZero[i - 1] + d\n                else:\n                    prefixVal[i] = d\n                    lenNonZero[i] = 1\n                    sumNonZero[i] = d\n        res = []\n        for l, r in queries:\n            if l == 0:\n                lenSeg = lenNonZero[r]\n                prevVal = 0\n                prevSum = 0\n            else:\n                lenSeg = lenNonZero[r] - lenNonZero[l - 1]\n                prevVal = prefixVal[l - 1]\n                prevSum = sumNonZero[l - 1]\n            if lenSeg == 0:\n                res.append(0)\n                continue\n            valSeg = (prefixVal[r] - prevVal * pow10[lenSeg]) % MOD\n            if valSeg < 0:\n                valSeg += MOD\n            sumSeg = sumNonZero[r] - prevSum\n            ans = (valSeg * sumSeg) % MOD\n            res.append(ans)\n        return res", "tests_passed": 3, "score": 0.8359375}
{"code": "import bisect\n\nclass Solution:\n    def solve(self, s, queries):\n        MOD = 10**9 + 7\n        digits = [int(c) for c in s]\n        n = len(digits := digits)\n        pos = []\n        arr = []\n        for idx, d in enumerate(digits):\n            if d != 0:\n                pos.append(idx)\n                arr.append(d)\n        m = len(arr)\n        if m == 0:\n            return [0] * len(queries)\n        pref_sum = [0]*m\n        pref_val = [0]*m\n        pow10 = [1]*(m+1)\n        for i in range(1, m+1):\n            pow10[i] = (pow10[i-1]*10) % MOD\n        for i, d in enumerate(arr):\n            if i==0:\n                pref_sum[i] = d\n                pref_val[i] = d % MOD\n            else:\n                pref_sum[i] = pref_sum[i-1] + d\n                pref_val[i] = (pref_val[i-1]*10 + d) % MOD\n        res = []\n        for l, r in queries:\n            i = bisect.bisect_left(pos, l)\n            j = bisect.bisect_right(pos, r) - 1\n            if i > j:\n                res.append(0)\n            else:\n                length = j - i + 1\n                sum_digits = pref_sum[j] - (pref_sum[i-1] if i>0 else 0)\n                val = pref_val[j] - (pref_val[i-1]*pow10[length] if i>0 else 0)\n                val %= MOD\n                ans = val * (sum_digits % MOD) % MOD\n                res.append(ans)\n        return res", "tests_passed": 3, "score": 0.83203125}
{"code": "import sys\nimport bisect\n\nMOD = 10**9 + 7\n\nclass Solution:\n    def nonZeroDigitsProductSum(self, s, queries):\n        m = len(s)\n        arr = []\n        pos = []\n        for i,ch in enumerate(s):\n            d = ord(ch)-48\n            if d != 0:\n                arr.append(d)\n                pos.append(i)\n        n = len(arr)\n        if n == 0:\n            return [0]*len(queries)\n        pref = [0]*n\n        sumPref = [0]*n\n        pref[0] = arr[0] % MOD\n        sumPref[0] = arr[0]\n        for i in range(1,n):\n            pref[i] = (pref[i-1]*10 + arr[i]) % MOD\n            sumPref[i] = sumPref[i-1] + arr[i]\n        pow10 = [1]*(n+1)\n        for i in range(1,n+1):\n            pow10[i] = (pow10[i-1]*10) % MOD\n        res = []\n        for l,r in queries:\n            left = bisect.bisect_left(pos,l)\n            right = bisect.bisect_right(pos,r)-1\n            if left>right:\n                res.append(0)\n                continue\n            a = left\n            b = right\n            if a==0:\n                x = pref[b]\n            else:\n                x = (pref[b] - pref[a-1]*pow10[b-a+1]) % MOD\n            sumDigits = sumPref[b] - (sumPref[a-1] if a>0 else 0)\n            ans = (x * sumDigits) % MOD\n            res.append(ans)\n        return res\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.nonZeroDigitsProductSum(\"10203004\", [[0,7],[1,3],[4,6]]))\n    print(sol.nonZeroDigitsProductSum(\"1000\", [[0,3],[1,1]]))\n    print(sol.nonZeroDigitsProductSum(\"9876543210\", [[0,9]]))", "tests_passed": 3, "score": 0.83203125}
{"code": "import sys\n\nMOD = 10 ** 9 + 7\n\nclass Solution:\n    def solve(self, s: str, queries: list[list[int]]) -> list[int]:\n        n = len(s)\n        active_positions = []\n        active_vals = []\n        for i, ch in enumerate(s):\n            if ch != '0':\n                active_positions.append(i)\n                active_vals.append(int(ch))\n        k = len(active_positions)\n\n        pref = [0] * (k + 1)\n        for i in range(k):\n            pref[i + 1] = (pref[i] * 10 + active_vals[i]) % MOD\n\n        sum_pref = [0] * (k + 1)\n        for i in range(k):\n            sum_pref[i + 1] = sum_pref[i] + active_vals[i]\n\n        pow10 = [1] * (k + 1)\n        for i in range(1, k + 1):\n            pow10[i] = (pow10[i - 1] * 10) % MOD\n\n        pos_to_idx = [-1] * n\n        for idx, pos in enumerate(active_positions):\n            pos_to_idx[pos] = idx\n\n        next_active = [-1] * (n + 1)\n        for i in range(n - 1, -1, -1):\n            if s[i] != '0':\n                next_active[i] = pos_to_idx[i]\n            else:\n                next_active[i] = next_active[i + 1]\n\n        prev_active = [-1] * n\n        for i in range(n):\n            if s[i] != '0':\n                prev_active[i] = pos_to_idx[i]\n            else:\n                prev_active[i] = prev_active[i - 1] if i > 0 else -1\n\n        res = []\n        for l, r in queries:\n            left = next_active[l]\n            right = prev_active[r]\n            if left == -1 or left > right:\n                res.append(0)\n                continue\n            seg_len = right - left + 1\n            val = (pref[right + 1] - pref[left] * pow10[seg_len]) % MOD\n            sum_seg = sum_pref[right + 1] - sum_pref[left]\n            res.append(val * sum_seg % MOD)\n        return res\n", "tests_passed": 3, "score": 0.83203125}
{"code": "import bisect\nclass Solution:\n    def solve(self, s: str, queries: list[list[int]]) -> list[int]:\n        MOD = 10**9 + 7\n        n = len(s)\n        pos = []\n        digits = []\n        for i,ch in enumerate(s):\n            if ch != '0':\n                pos.append(i)\n                digits.append(ord(ch)-48)\n        m = len(digits := digits)\n        if m == 0:\n            return [0]*len(queries)\n        prefix_sum = [0]*m\n        prefix_val = [0]*m\n        pow10 = [1]*(m+1)\n        for i in range(1,m+1):\n            pow10[i] = (pow10[i-1]*10)%MOD\n        for i,d in enumerate(digits):\n            if i==0:\n                prefix_sum[i] = d\n                prefix_val[i] = d\n            else:\n                prefix_sum[i] = (prefix_sum[i-1]+d)%MOD\n                prefix_val[i] = (prefix_val[i-1]*10 + d)%MOD\n        res = []\n        for l,r in queries:\n            lIdx = bisect.bisect_left(pos,l)\n            rIdx = bisect.bisect_right(pos,r)-1\n            if lIdx>rIdx:\n                res.append(0)\n                continue\n            length = rIdx-lIdx+1\n            if lIdx==0:\n                val = prefix_val[rIdx]\n                sm = prefix_sum[rIdx]\n            else:\n                val = (prefix_val[rIdx] - prefix_val[lIdx-1]*pow10[length])%MOD\n                sm = (prefix_sum[rIdx] - prefix_sum[lIdx-1])%MOD\n            res.append(val*sm%MOD)\n        return res", "tests_passed": 3, "score": 0.828125}
{"code": "import bisect\n\nclass Solution:\n    def solve(self, s, queries):\n        MOD = 10**9 + 7\n        n = len(s)\n        digits = []\n        pos = []\n        for i,ch in enumerate(s):\n            if ch!='0':\n                digits.append(int(ch))\n                pos.append(i)\n        m = len(digits)\n        if m==0:\n            return [0]*len(queries)\n        pow10 = [1]*(m+1)\n        for i in range(1,m+1):\n            pow10[i] = pow10[i-1]*10%MOD\n        pref_mod = [0]*m\n        pref_sum = [0]*m\n        pref_mod[0] = digits[0]\n        pref_sum[0] = digits[0]\n        for i in range(1,m):\n            pref_mod[i] = (pref_mod[i-1]*10 + digits[i])%MOD\n            pref_sum[i] = pref_sum[i-1] + digits[i]\n        ans = []\n        for l,r in queries:\n            a = bisect.bisect_left(pos,l)\n            b = bisect.bisect_right(pos,r)-1\n            if a> b:\n                ans.append(0)\n                continue\n            if a==0:\n                sub = pref_mod[b]\n            else:\n                sub = (pref_mod[b] - pref_mod[a-1]*pow10[b-a+1])%MOD\n            sum_sub = pref_sum[b] - (pref_sum[a-1] if a>0 else 0)\n            ans.append(sub*sum_sub%MOD)\n        return ans\n", "tests_passed": 3, "score": 0.82421875}
{"code": "import sys\n\nclass Solution:\n    def solve(self, s: str, queries):\n        mod = 1000000007\n        n = len(s)\n        pref_mod = [0]*(n+1)\n        pref_cnt = [0]*(n+1)\n        pref_sum = [0]*(n+1)\n        pow10 = [1]*(n+1)\n        for i in range(1, n+1):\n            pow10[i] = (pow10[i-1]*10) % mod\n        for i,ch in enumerate(s,1):\n            d = ord(ch)-48\n            if d:\n                pref_mod[i] = (pref_mod[i-1]*10 + d) % mod\n                pref_cnt[i] = pref_cnt[i-1] + 1\n                pref_sum[i] = pref_sum[i-1] + d\n            else:\n                pref_mod[i] = pref_mod[i-1]\n                pref_cnt[i] = pref_cnt[i-1]\n                pref_sum[i] = pref_sum[i-1]\n        ans=[]\n        for l,r in queries:\n            l0=l\n            r0=r+1\n            len_sub = pref_cnt[r0]-pref_cnt[l0]\n            if len_sub==0:\n                ans.append(0)\n                continue\n            val = (pref_mod[r0]-pref_mod[l0]*pow10[len_sub])%mod\n            summ = pref_sum[r0]-pref_sum[l0]\n            ans.append(val*summ%mod)\n        return ans", "tests_passed": 3, "score": 0.82421875}
{"code": "import bisect\n\nclass Solution:\n    def nonZeroSubstrings(self, s, queries):\n        MOD = 10**9 + 7\n        n = len(s)\n        digits = []\n        pos = []\n        for i,ch in enumerate(s):\n            d = ord(ch) - 48\n            if d != 0:\n                digits.append(d)\n                pos.append(i)\n        m = len(digits)\n\n        if m == 0:\n            return [0]*len(queries)\n\n        pow10 = [1]*(m+1)\n        for i in range(1,m+1):\n            pow10[i] = (pow10[i-1]*10)%MOD\n\n        pref = [0]*m\n        pref[0] = digits[0]%MOD\n        for i in range(1,m):\n            pref[i] = (pref[i-1]*10 + digits[i])%MOD\n\n        prefSum = [0]*m\n        prefSum[0] = digits[0]\n        for i in range(1,m):\n            prefSum[i] = prefSum[i-1] + digits[i]\n\n        res = []\n        for l,r in queries:\n            left = bisect.bisect_left(pos, l)\n            right = bisect.bisect_right(pos, r)-1\n            if left>right:\n                res.append(0)\n                continue\n            length = right-left+1\n            if left==0:\n                val = pref[right]\n            else:\n                val = (pref[right] - pref[left-1]*pow10[length])%MOD\n            sum_seg = prefSum[right] - (prefSum[left-1] if left>0 else 0)\n            res.append((val*sum_seg)%MOD)\n        return res", "tests_passed": 3, "score": 0.82421875}
{"code": "import sys\nfrom typing import List\n\nclass Solution:\n    def solve(self, s: str, queries: List[List[int]]) -> List[int]:\n        mod = 10**9 + 7\n        m = len(s)\n        digits = [int(ch) for ch in s]\n        prefX = [0]*m\n        prefCnt = [0]*m\n        prefSum = [0]*m\n        pow10 = [1]*(m+1)\n        for i in range(1, m+1):\n            pow10[i] = (pow10[i-1]*10) % mod\n        if digits[0] != 0:\n            prefX[0] = digits[0]\n            prefCnt[0] = 1\n            prefSum[0] = digits[0]\n        else:\n            prefX[0] = 0\n            prefCnt[0] = 0\n            prefSum[0] = 0\n        for i in range(1, m):\n            d = digits[i]\n            if d != 0:\n                prefX[i] = (prefX[i-1]*10 + d) % mod\n                prefCnt[i] = prefCnt[i-1] + 1\n                prefSum[i] = prefSum[i-1] + d\n            else:\n                prefX[i] = prefX[i-1]\n                prefCnt[i] = prefCnt[i-1]\n                prefSum[i] = prefSum[i-1]\n        res = []\n        for l, r in queries:\n            cnt_r = prefCnt[r]\n            sum_r = prefSum[r]\n            if l > 0:\n                cnt_l = prefCnt[l-1]\n                sum_l = prefSum[l-1]\n                x_l = prefX[l-1]\n            else:\n                cnt_l = 0\n                sum_l = 0\n                x_l = 0\n            cnt_diff = cnt_r - cnt_l\n            sum_sub = sum_r - sum_l\n            pow_diff = pow10[cnt_diff]\n            x_sub = (prefX[r] - x_l * pow_diff) % mod\n            ans = (x_sub * sum_sub) % mod\n            res.append(ans)\n        return res", "tests_passed": 3, "score": 0.82421875}
{"code": "import sys\n\nclass Solution:\n    def queryAnswers(self, s: str, queries: list[list[int]]) -> list[int]:\n        MOD = 10 ** 9 + 7\n        n = len(s)\n        pow10 = [1] * (n + 1)\n        for i in range(1, n + 1):\n            pow10[i] = (pow10[i - 1] * 10) % MOD\n        prefX = [0] * (n + 1)\n        prefSum = [0] * (n + 1)\n        cnt = [0] * (n + 1)\n        for i, ch in enumerate(s, 1):\n            d = int(ch)\n            if d:\n                prefX[i] = (prefX[i - 1] * 10 + d) % MOD\n                prefSum[i] = prefSum[i - 1] + d\n                cnt[i] = cnt[i - 1] + 1\n            else:\n                prefX[i] = prefX[i - 1]\n                prefSum[i] = prefSum[i - 1]\n                cnt[i] = cnt[i - 1]\n        res = []\n        for l, r in queries:\n            before = cnt[l]\n            after = cnt[r + 1]\n            k = after - before\n            if k == 0:\n                res.append(0)\n                continue\n            x = (prefX[r + 1] - prefX[l] * pow10[k]) % MOD\n            ssum = prefSum[r + 1] - prefSum[l]\n            res.append(x * ssum % MOD)\n        return res", "tests_passed": 3, "score": 0.81640625}
{"code": "import bisect\n\nMOD = 10**9+7\n\nclass Solution:\n    def sumAndProduct(self, s, queries):\n        m = len(s)\n        pos = []\n        digits = []\n        for i,ch in enumerate(s):\n            if ch!='0':\n                pos.append(i)\n                digits.append(int(ch))\n        n = len(pos)\n        pref_val = [0]*(n+1)\n        pref_sum = [0]*(n+1)\n        for i in range(n):\n            pref_val[i+1] = (pref_val[i]*10 + digits[i])%MOD\n            pref_sum[i+1] = pref_sum[i] + digits[i]\n        pow10 = [1]*(n+1)\n        for i in range(1,n+1):\n            pow10[i] = (pow10[i-1]*10)%MOD\n        ans = []\n        for l,r in queries:\n            left = bisect.bisect_left(pos,l)\n            right = bisect.bisect_right(pos,r)-1\n            if left>right:\n                ans.append(0)\n                continue\n            k = right-left+1\n            x = (pref_val[right+1] - pref_val[left]*pow10[k])%MOD\n            total = pref_sum[right+1] - pref_sum[left]\n            ans.append((x*total)%MOD)\n        return ans", "tests_passed": 3, "score": 0.81640625}
{"code": "import sys\n\nclass Solution:\n    def processQueries(self, s, queries):\n        MOD = 10**9 + 7\n        n = len(s)\n        pow10 = [1] * (n + 1)\n        for i in range(1, n + 1):\n            pow10[i] = (pow10[i - 1] * 10) % MOD\n        pref_x = [0] * n\n        pref_sum = [0] * n\n        cnt = [0] * n\n        val = 0\n        sm = 0\n        c = 0\n        for i, ch in enumerate(s):\n            d = ord(ch) - 48\n            if d != 0:\n                val = (val * 10 + d) % MOD\n                sm += d\n                c += 1\n            pref_x[i] = val\n            pref_sum[i] = sm\n            cnt[i] = c\n        res = []\n        for l, r in queries:\n            if l == 0:\n                pref_x_lm1 = 0\n                pref_sum_lm1 = 0\n                cnt_lm1 = 0\n            else:\n                pref_x_lm1 = pref_x[l - 1]\n                pref_sum_lm1 = pref_sum[l - 1]\n                cnt_lm1 = cnt[l - 1]\n            k = cnt[r] - cnt_lm1\n            if k == 0:\n                res.append(0)\n                continue\n            x_sub = (pref_x[r] - pref_x_lm1 * pow10[k]) % MOD\n            sum_sub = pref_sum[r] - pref_sum_lm1\n            res.append((x_sub * sum_sub) % MOD)\n        return res", "tests_passed": 3, "score": 0.8125}
{"code": "import sys\n\nclass Solution:\n    def solve(self, s: str, queries):\n        MOD = 10**9 + 7\n        n = len(s)\n        pow10 = [1]*(n+1)\n        for i in range(1, n+1):\n            pow10[i] = (pow10[i-1]*10)%MOD\n        cnt = [0]*(n+1)\n        sumd = [0]*(n+1)\n        val = [0]*(n+1)\n        for i in range(1, n+1):\n            d = ord(s[i-1]) - 48\n            if d:\n                cnt[i] = cnt[i-1]+1\n                sumd[i] = sumd[i-1]+d\n                val[i] = (val[i-1]*10 + d)%MOD\n            else:\n                cnt[i] = cnt[i-1]\n                sumd[i] = sumd[i-1]\n                val[i] = val[i-1]\n        res = []\n        for l,r in queries:\n            cntDiff = cnt[r+1]-cnt[l]\n            x = (val[r+1] - val[l]*pow10[cntDiff])%MOD\n            sm = sumd[r+1]-sumd[l]\n            res.append((x*sm)%MOD)\n        return res", "tests_passed": 3, "score": 0.8125}
{"code": "import sys\n\nclass Solution:\n    def substringProducts(self, s, queries):\n        MOD = 10**9 + 7\n        m = len(s)\n        # prefix count of non-zero digits up to position i\n        pos = [0] * (m + 1)\n        for i in range(m):\n            pos[i + 1] = pos[i] + (s[i] != '0')\n        n_nonzero = pos[m]\n        # arrays 1-indexed for non-zero digits\n        D = [0] * (n_nonzero + 1)\n        sumD = [0] * (n_nonzero + 1)\n        value = [0] * (n_nonzero + 1)\n        for i in range(m):\n            if s[i] != '0':\n                idx = pos[i + 1]\n                d = ord(s[i]) - 48\n                D[idx] = d\n                sumD[idx] = sumD[idx - 1] + d\n                value[idx] = (value[idx - 1] * 10 + d) % MOD\n        pow10 = [1] * (n_nonzero + 1)\n        for k in range(1, n_nonzero + 1):\n            pow10[k] = (pow10[k - 1] * 10) % MOD\n        res = []\n        for l, r in queries:\n            a = pos[l] + 1\n            b = pos[r + 1]\n            if a > b:\n                res.append(0)\n                continue\n            length = b - a + 1\n            x_mod = (value[b] - value[a - 1] * pow10[length]) % MOD\n            sum_digits = sumD[b] - sumD[a - 1]\n            ans = (x_mod * sum_digits) % MOD\n            res.append(ans)\n        return res\nif __name__ == \"__main__\":\n    s = \"10203004\"\n    queries = [[0,7],[1,3],[4,6]]\n    sol = Solution()\n    print(sol.substringProducts(s, queries))\nif __name__ == \"__main__\":\n    s = \"1000\"\n    queries = [[0,3],[1,1]]\n    sol = Solution()\n    print(sol.substringProducts(s, queries))\nif __name__ == \"__main__\":\n    s = \"9876543210\"\n    queries = [[0,9]]\n    sol = Solution()\n    print(sol.substringProducts(s, queries))", "tests_passed": 3, "score": 0.8125}
{"code": "import sys\n\nMOD = 10 ** 9 + 7\n\nclass Solution:\n    def answerQueries(self, s, queries):\n        m = len(s)\n        val = [0] * m\n        cnt = [0] * m\n        sm = [0] * m\n        pow10 = [1] * (m + 1)\n        for i in range(1, m + 1):\n            pow10[i] = (pow10[i - 1] * 10) % MOD\n        cur_val = 0\n        cur_cnt = 0\n        cur_sum = 0\n        for i, ch in enumerate(s):\n            d = ord(ch) - 48\n            if d:\n                cur_val = (cur_val * 10 + d) % MOD\n                cur_cnt += 1\n                cur_sum += d\n            val[i] = cur_val\n            cnt[i] = cur_cnt\n            sm[i] = cur_sum\n        res = []\n        for l, r in queries:\n            if l == 0:\n                val_lminus = 0\n                cnt_lminus = 0\n                sum_lminus = 0\n            else:\n                val_lminus = val[l - 1]\n                cnt_lminus = cnt[l - 1]\n                sum_lminus = sm[l - 1]\n            k = cnt[r] - cnt_lminus\n            x = (val[r] - val_lminus * pow10[k]) % MOD\n            total_sum = sm[r] - sum_lminus\n            ans = x * total_sum % MOD\n            res.append(ans)\n        return res", "tests_passed": 3, "score": 0.8125}
{"code": "import sys\nMOD = 10**9 + 7\n\nclass Solution:\n    def getAnswer(self, s: str, queries: list[list[int]]) -> list[int]:\n        n = len(s)\n        pow10 = [1] * (n + 1)\n        for i in range(1, n + 1):\n            pow10[i] = (pow10[i - 1] * 10) % MOD\n\n        size = 1\n        while size < n:\n            size <<= 1\n        val = [0] * (2 * size)\n        length = [0] * (2 * size)\n        summ = [0] * (2 * size)\n\n        for i in range(n):\n            d = ord(s[i]) - 48\n            if d != 0:\n                val[size + i] = d\n                length[size + i] = 1\n                summ[size + i] = d\n        for i in range(size - 1, 0, -1):\n            l = 2 * i\n            r = l + 1\n            lv, ll, ls = val[l], length[l], summ[l]\n            rv, rl, rs = val[r], length[r], summ[r]\n            val[i] = (lv * pow10[rl] + rv) % MOD\n            length[i] = ll + rl\n            summ[i] = ls + rs\n\n        res = []\n        for l, r in queries:\n            l += size\n            r += size + 1\n            left_val = left_len = left_sum = 0\n            right_val = right_len = right_sum = 0\n            while l < r:\n                if l & 1:\n                    lv, ll, ls = val[l], length[l], summ[l]\n                    left_val = (left_val * pow10[ll] + lv) % MOD\n                    left_len += ll\n                    left_sum += ls\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    rv, rl, rs = val[r], length[r], summ[r]\n                    right_val = (rv * pow10[right_len] + right_val) % MOD\n                    right_len += rl\n                    right_sum += rs\n                l >>= 1\n                r >>= 1\n            final_val = (left_val * pow10[right_len] + right_val) % MOD\n            final_sum = left_sum + right_sum\n            res.append(final_val * final_sum % MOD)\n        return res", "tests_passed": 3, "score": 0.80859375}
{"code": "import bisect\n\nMOD = 10**9 + 7\n\nclass Solution:\n    def calculateXOR(self, s: str, queries) -> list:\n        n = len(s)\n        digits = [int(ch) for ch in s]\n        pos_nonzero = [i for i, d in enumerate(digits) if d != 0]  # but digits defined as variable; fix below\n\n        # Correcting the above: we'll recompute properly\n        pos_nonzero = []\n        a = []\n        for i, ch in enumerate(s):\n            d = int(ch)\n            if d != 0:\n                pos_nonzero.append(i)\n                a.append(d)\n        m = len(a)\n        pref_val = [0] * (m + 1)\n        pref_sum = [0] * (m + 1)\n        pow10 = [1] * (m + 1)\n        for i in range(1, m + 1):\n            pref_val[i] = (pref_val[i-1] * 10 + a[i-1]) % MOD\n            pref_sum[i] = pref_sum[i-1] + a[i-1]\n            pow10[i] = (pow10[i-1] * 10) % MOD\n        res = []\n        for l, r in queries:\n            left = bisect.bisect_left(pos_nonzero, l)\n            right = bisect.bisect_right(pos_nonzero, r)\n            k = right - left\n            if k == 0:\n                res.append(0)\n                continue\n            sum_digits = pref_sum[right] - pref_sum[left]\n            val = (pref_val[right] - pref_val[left] * pow10[k]) % MOD\n            ans = val * sum_digits % MOD\n            res.append(ans)\n        return res", "tests_passed": 3, "score": 0.80859375}
{"code": "import sys\n\nMOD = 10**9 + 7\n\nclass Solution:\n    def solve(self, s: str, queries: list[list[int]]) -> list[int]:\n        m = len(s)\n        pow10 = [1] * (m + 1)\n        for i in range(1, m + 1):\n            pow10[i] = (pow10[i - 1] * 10) % MOD\n\n        cnt = [0] * m\n        val = [0] * m\n        sm = [0] * m\n\n        c = 0\n        v = 0\n        ssum = 0\n        for i, ch in enumerate(s):\n            d = ord(ch) - 48\n            if d != 0:\n                c += 1\n                v = (v * 10 + d) % MOD\n                ssum += d\n            cnt[i] = c\n            val[i] = v\n            sm[i] = ssum\n\n        res = []\n        for l, r in queries:\n            cntR = cnt[r]\n            cntL = cnt[l - 1] if l > 0 else 0\n            valR = val[r]\n            valL = val[l - 1] if l > 0 else 0\n            sum_sub = sm[r] - (sm[l - 1] if l > 0 else 0)\n            x = (valR - valL * pow10[cntR - cntL]) % MOD\n            res.append((x * sum_sub) % MOD)\n        return res\n", "tests_passed": 3, "score": 0.80078125}
{"code": "import sys\n\nMOD = 10**9 + 7\n\nclass Solution:\n    def processQueries(self, s, queries):\n        n = len(s)\n        size = 1\n        while size < n:\n            size <<= 1\n        # precompute powers of 10\n        pow10 = [1] * (n + 1)\n        for i in range(1, n + 1):\n            pow10[i] = (pow10[i - 1] * 10) % MOD\n        # tree arrays\n        x = [0] * (2 * size)\n        sumv = [0] * (2 * size)\n        cnt = [0] * (2 * size)\n        for i in range(n):\n            d = ord(s[i]) - 48\n            if d:\n                idx = size + i\n                x[idx] = d % MOD\n                sumv[idx] = d\n                cnt[idx] = 1\n        for i in range(size - 1, 0, -1):\n            l = i << 1\n            r = l | 1\n            cl = cnt[l]; cr = cnt[r]\n            if cl == 0:\n                x[i] = x[r]\n                sumv[i] = sumv[r]\n                cnt[i] = cr\n            elif cr == 0:\n                x[i] = x[l]\n                sumv[i] = sumv[l]\n                cnt[i] = cl\n            else:\n                x[i] = (x[l] * pow10[cr] + x[r]) % MOD\n                sumv[i] = sumv[l] + sumv[r]\n                if sumv[i] >= MOD:\n                    sumv[i] -= MOD\n                cnt[i] = cl + cr\n        res = []\n        for l, r in queries:\n            l += size\n            r += size + 1\n            left_x = 0; left_sum = 0; left_cnt = 0\n            right_x = 0; right_sum = 0; right_cnt = 0\n            while l < r:\n                if l & 1:\n                    if left_cnt == 0:\n                        left_x = x[l]; left_sum = sumv[l]; left_cnt = cnt[l]\n                    else:\n                        left_x = (left_x * pow10[cnt[l]] + x[l]) % MOD\n                        left_sum += sumv[l]\n                        if left_sum >= MOD:\n                            left_sum -= MOD\n                        left_cnt += cnt[l]\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    if right_cnt == 0:\n                        right_x = x[r]; right_sum = sumv[r]; right_cnt = cnt[r]\n                    else:\n                        right_x = (x[r] * pow10[right_cnt] + right_x) % MOD\n                        right_sum += sumv[r]\n                        if right_sum >= MOD:\n                            right_sum -= MOD\n                        right_cnt += cnt[r]\n                l >>= 1; r >>= 1\n            if left_cnt == 0:\n                total_x = right_x\n                total_sum = right_sum\n            elif right_cnt == 0:\n                total_x = left_x\n                total_sum = left_sum\n            else:\n                total_x = (left_x * pow10[right_cnt] + right_x) % MOD\n                total_sum = left_sum + right_sum\n                if total_sum >= MOD:\n                    total_sum -= MOD\n            ans = (total_x * total_sum) % MOD\n            res.append(ans)\n        return res\nif __name__ == \"__main__\":\n    pass", "tests_passed": 3, "score": 0.734375}
{"code": "import sys\n\nclass Solution:\n    def digitSumProduct(self, s: str, queries: list[list[int]]) -> list[int]:\n        MOD = 10**9 + 7\n        n = len(s)\n        size = 1\n        while size < n:\n            size <<= 1\n        val = [0] * (2 * size)\n        sm = [0] * (2 * size)\n        cnt = [0] * (2 * size)\n        pow10 = [1] * (n + 1)\n        for i in range(1, n + 1):\n            pow10[i] = (pow10[i - 1] * 10) % MOD\n        for i in range(n):\n            d = ord(s[i]) - 48\n            if d != 0:\n                val[size + i] = d\n                sm[size + i] = d\n                cnt[size + i] = 1\n        for i in range(size - 1, 0, -1):\n            l = 2 * i\n            r = l + 1\n            c = cnt[l] + cnt[r]\n            cnt[i] = c\n            val[i] = (val[l] * pow10[cnt[r]] + val[r]) % MOD\n            sm[i] = (sm[l] + sm[r]) % MOD\n        res = []\n        for l, r in queries:\n            l += size\n            r += size\n            resl_val = resl_sm = resl_cnt = 0\n            resr_val = resr_sm = resr_cnt = 0\n            while l <= r:\n                if l % 2 == 1:\n                    resl_cnt += cnt[l]\n                    resl_val = (resl_val * pow10[cnt[l]] + val[l]) % MOD\n                    resl_sm = (resl_sm + sm[l]) % MOD\n                    l += 1\n                if r % 2 == 0:\n                    resr_cnt += cnt[r]\n                    resr_val = (val[r] * pow10[resr_cnt] + resr_val) % MOD\n                    resr_sm = (sm[r] + resr_sm) % MOD\n                    r -= 1\n                l //= 2\n                r //= 2\n            total_cnt = resl_cnt + resr_cnt\n            total_val = (resl_val * pow10[resr_cnt] + resr_val) % MOD\n            total_sm = (resl_sm + resr_sm) % MOD\n            res.append((total_val * total_sm) % MOD)\n        return res\n\nif __name__ == \"__main__\":\n    pass", "tests_passed": 1, "score": 0.796875}
{"code": "import bisect\n\nclass Solution:\n    def sumOfConcatenatedDigits(self, s, queries):\n        MOD = 10**9 + 7\n        n = len(s)\n        # positions of non-zero digits\n        pos = [i for i, ch in enumerate(s) if ch != '0']\n        m = len(pos)\n        if m == 0:\n            return [0] * len(queries)\n        digits = [int(s[i]) for i in pos]\n        pref_val = [0] * (m + 1)\n        pref_sum = [0] * (m + 1)\n        pow10 = [1] * (m + 1)\n        for i in range(1, m + 1):\n            pow10[i] = (pow10[i - 1] * 10) % MOD\n            pref_val[i] = (pref_val[i - 1] * 10 + digits[i - 1]) % MOD\n            pref_sum[i] = pref_sum[i - 1]", "tests_passed": 0, "score": 0.8359375}
{"code": "import bisect\n\nMOD = 10**9 + 7\n\nclass Solution:\n    def evaluateQueries(self, s, queries):\n        m = len(s)\n        pos = []\n        digits = []\n        for i, ch in enumerate(s):\n            if ch != '0':\n                pos.append(i)\n                digits.append(int(ch))\n        k = len(digits := digits)\n        prefixX = [0] * (k + 1)\n        prefixSum = [0] * (k + 1)\n        pow10 = [1] * (k + 1)\n        for i in range(1, k + 1):\n            d = digits[i - 1]\n            prefixX[i] = (prefixX[i - 1] * 10 + d) % MOD\n            prefixSum[i] = (prefixSum[i - 1] + d) % MOD\n            pow10[i] = pow10[i - 1] * 10 % MOD\n        ans = []\n        for limport bisect\n\nclass Solution:\n    def nonZeroSumProduct(self, s: str, queries: list[list[int]]) -> list[int]:\n        MOD = 10**9 + 7\n        n = len(s)\n        pos = []\n        digits = []\n        for idx, ch in enumerate(s):\n            if ch != '0':\n                pos.append(idx)\n                digits.append(int(ch))\n        m = len(pos)\n        if m == 0:\n            return [0]*len(queries)\n        pow10 = [1]*(m+1)\n        for i in range(1, m+1):\n            pow10[i] = (pow10[i-1]*10) % MOD\n        pref = [0]*m\n        sumdig = [0]*m\n        pref[0] = digits[0]\n        sumdig[0] = digits[0]\n        for i in range(1, m):\n            pref[i] = (pref[i-1]*10 + digits[i]) % MOD\n            sumdig[i] = sumdig[i-1] + digits[i]\n        ans = []\n        for l, r in queries:\n            i = bisect.bisect_left(pos, l)\n            j = bisect.bisect_right(pos, r) - 1\n            if i > j:\n                ans.append(0)\n                continue\n            length = j - i + 1\n            if i == 0:\n                val = pref[j]\n            else:\n                val = (pref[j] - pref[i-1]*pow10[length]) % MOD\n            ssum = sumdig[j] - (sumdig[i-1] if i>0 else 0)\n            ans.append(val * ssum % MOD)\n        return ans", "tests_passed": 0, "score": 0.83203125}
{"code": "import sys\n\nclass Solution:\n    def calculateAnswers(self, s: str, queries: list[list[int]]) -> list[int]:\n        MOD = 10 ** 9 + 7import sys\nclass Solution:\n    def queryAnswers(self, s: str, queries: list[list[int]]) -> list[int]:\n        MOD = 10**9 + 7\n        n = len(s)\n        pv = [0] * (n + 1)\n        psum = [0] * (n + 1)\n        pcnt = [0] * (n + 1)\n        pow10 = [1] * (n + 1)\n        for i in range(1, n + 1):\n            pow10[i] = (pow10[i - 1] * 10) % MOD\n        for i, ch in enumerate(s, 1):\n            d = ord(ch) - 48\n            if d != 0:\n                pv[i] = (pv[i - 1] * 10 + d) % MOD\n                psum[i] = psum[i - 1] + d\n                pcnt[i] = pcnt[i - 1] + 1\n            else:\n                pv[i] = pv[i - 1]\n                psum[i] = psum[i - 1]\n                pcnt[i] = pcnt[i - 1]\n        ans = []\n        for l, r in queries:\n            k = pcnt[r + 1] - pcnt[l]\n            if k == 0:\n                ans.append(0)\n                continue\n            x = (pv[r + 1] - pv[l] * pow10[k]) % MOD\n            ssum = psum[r + 1] - psum[l]\n            ans.append((x * ssum) % MOD)\n        return ans", "tests_passed": 0, "score": 0.82421875}
{"code": "import sys\nclass Solution:\n    def subNumberAndProduct(self, s: str, queries: list[list[int]]) -> list[int]:\n        MOD = 10**9 + 7\n        n = len(s)\n        pow10 = [1] * (n + 1)\n        for i in range(1, n + 1):\n            pow10[i] = (pow10[i-1] * 10) % MOD\n        pref_x = [0] * n\n        pref_sum = [0] * n\n        cnt = [0] * n\n        for i, ch in enumerate(s):\n            d = ord(ch) - 48\n            if i > 0:\n                pref_x[i] = pref_x[i-1]\n                pref_sum[i] = pref_sum[i-1]\n                cnt[i] = cnt[i-1]\n            else:\n                pref_x[i] = 0\n                pref_sum[i] = 0\n                cnt[i] = 0\n            if d != 0:\n                pref_x[i] = (pref_x[i] * 10 + d) % MOD\n                pref_sum[i] += d\n                cnt[i] += 1\n        res = []\n        for l, r in queries:\n            cnt_l = cnt[l-1] if l > 0 else 0\n            t = cnt[r] - cnt_l\n            x_r = pref_x[r]\n            x", "tests_passed": 0, "score": 0.81640625}
